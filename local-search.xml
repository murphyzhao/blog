<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>解读乐鑫 AT 指令解析器，解锁你不知道的用法</title>
    <link href="/posts/a1efac9d.html"/>
    <url>/posts/a1efac9d.html</url>
    
    <content type="html"><![CDATA[<h1 id="解读乐鑫-AT-指令解析器，解锁你不知道的用法（全网唯一）"><a href="#解读乐鑫-AT-指令解析器，解锁你不知道的用法（全网唯一）" class="headerlink" title="解读乐鑫 AT 指令解析器，解锁你不知道的用法（全网唯一）"></a>解读乐鑫 AT 指令解析器，解锁你不知道的用法（全网唯一）</h1><p>欢迎关注、星标 🌟 <strong>物联网学前班</strong> 公众号，畅享精彩内容</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/logo/WeChat/ErWeiMaSouYiSouBaiSe.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>由于近期正好在做这个事情，所以今天就以乐鑫的 AT 指令为例，讲讲 AT 解析器设计有哪些事情，也算是个自己近期的学习总结了。</p></blockquote><h2 id="往期文章回顾"><a href="#往期文章回顾" class="headerlink" title="往期文章回顾"></a>往期文章回顾</h2><ul><li>1、<a href="https://mp.weixin.qq.com/s/nd4NzSVX_7dhQ-gkJlVfiQ" target="_blank" rel="noopener">AT 指令介绍</a></li><li>2、<a href="https://mp.weixin.qq.com/s/yfQbjSo80oD16mIXpeBlsg" target="_blank" rel="noopener">初体验乐鑫 ESP32 AT 指令</a></li></ul><h2 id="少有人关注的-AT-解析器"><a href="#少有人关注的-AT-解析器" class="headerlink" title="少有人关注的 AT 解析器"></a>少有人关注的 AT 解析器</h2><p>互联网上很多 xxx AT 指令使用教程，为何少有人关注 AT 解析器呢？</p><p>情况是这样的，绝大部分开发者是拿 AT 固件来开发产品的，只有很少一部分人是开发 AT 固件的。AT 固件通常是由芯片原厂、模组厂商来提供的，并且大多模组厂商也仅基于芯片原厂提供的 AT 解析器自定义 AT 指令。所以设计 AT 解析器的人就更少了，由于芯片原厂通常又不会提供 SDK 源码到互联网上，因此也基本上看不到 AT 解析器分析的文章。所以，互联网上关于 AT 的文章大都是某某模块都 AT 指令如何使用、怎么使用 MCU 控制 AT 指令模块。</p><p>总结：用 AT 固件都多，开发 AT 固件的少，设计 AT 解析器的人更少。</p><h2 id="玩得好规则，才做得好产品"><a href="#玩得好规则，才做得好产品" class="headerlink" title="玩得好规则，才做得好产品"></a>玩得好规则，才做得好产品</h2><p>想要写一个好的 AT 解析器，或者你想解析 AT 指令的响应，你首先得知道 AT 指令的规则，清楚不同指令共性的地方和差异的地方。</p><p>关于 AT 指令语法格式可以参考我的这篇文章 <a href="https://mp.weixin.qq.com/s/nd4NzSVX_7dhQ-gkJlVfiQ" target="_blank" rel="noopener">AT 指令介绍</a>。</p><h2 id="标准晦涩难懂，寻个实际产品"><a href="#标准晦涩难懂，寻个实际产品" class="headerlink" title="标准晦涩难懂，寻个实际产品"></a>标准晦涩难懂，寻个实际产品</h2><p>以乐鑫的 AT 解析器 <a href="https://github.com/espressif/esp-at" target="_blank" rel="noopener">esp-at</a> 为例，说说 AT 解析器涉及的内容。</p><p>乐鑫的 AT 指令语法也是遵循 <a href="http://www.arib.or.jp/english/html/overview/doc/STD-T63v9_30/5_Appendix/Rel10/27/27007-a70.pdf" target="_blank" rel="noopener">3GPP TS 27.007</a> 语法规范。</p><h3 id="AT-指令共性的内容"><a href="#AT-指令共性的内容" class="headerlink" title="AT 指令共性的内容"></a>AT 指令共性的内容</h3><ol><li>遵循 AT 规范，AT 开头，CRLF 结尾（考虑到有些平台只用 LF 的情况，CRLF 结尾还需要容错）；</li><li>有五类 AT 指令（TEST, GET, SET, EXEC），这里不带加号算作是 basic 指令；</li><li>字符串类型使用双引号（”string”）括起来；</li><li>整数类型不实使用双引号；</li><li>特殊字符需要转译；</li><li>等号后面必须有一个参数（当然你的解析器也可以容忍等号后面无参数，作为默认参数填充，这样的话跟执行命令又有什么不同呢）；</li><li>支持省略参数。</li></ol><p>以上这些都是需要基于 AT 解析器实现。</p><h3 id="AT-指令差异的内容"><a href="#AT-指令差异的内容" class="headerlink" title="AT 指令差异的内容"></a>AT 指令差异的内容</h3><ol><li><p>参数数量不定</p></li><li><p>参数类型不定</p></li><li><p>是否有 <strong>省略参数</strong></p></li><li><p>参数内容不同</p><ul><li>是否使用来非 ascii 文本</li><li>是否使用来特殊符号</li><li>各种可能性的 AT 指令格式错误（人为原因）</li><li>是否有需要 <strong>转译</strong> 的字符，转译规则是怎么样的</li></ul></li></ol><p>由于这些都是跟用户输入紧密相关的，解析器事先并不知道，要想解析这些情况下的文本，我们需要先定好规则，告诉解析器支持什么、不支持什么、特殊特性如何支持等，然后用户按照既定的规则输入正确的指令，同时解析器也应该能检测到错误格式的指令并报告错误。</p><p>以上 4 条里，最麻烦的就是第四条——用户可能使用任何可打印文本，另外最复杂的还是处理 <strong>待转译的字符</strong>。</p><h3 id="转译字符语法"><a href="#转译字符语法" class="headerlink" title="转译字符语法"></a>转译字符语法</h3><p>乐鑫给出里下面几个需要转译的字符：</p><ul><li>反斜杠本身 <code>\</code>，转译用法 <code>\\</code></li><li>逗号 <code>,</code>，转译用法 <code>\,</code></li><li>双引号 <code>&quot;</code>，转译用法 <code>\&quot;</code></li><li><code>\&lt;any&gt;</code>，意思是使用 <code>\</code> 后面的所有字符 <code>&lt;any&gt;</code> 替代这里的 <code>\</code></li></ul><p>用 <code>AT+CWSAP=&lt;ssid&gt;,&lt;pwd&gt;,&lt;channel&gt;,&lt;ecn&gt;</code> 指令举例，改指令用于启动一个 AP 热点，举例如下：</p><pre><code>AT+CWJAP=&quot;ssid_\\\&quot;\,\&quot;\&lt;any&gt;\&lt;\&quot;\,\\\123中文&gt;&quot;, &quot;12345678&quot;,6,0</code></pre><p>上面这条指令会启动一个 AP 热点，ssid 名称将是 <code>ssid_\&quot;,&quot;&lt;any&gt;&lt;&quot;,\123中文&gt;</code>，密码是 <code>12345678</code>，信道是 6，加密方式是 open。有硬件条件的用户可以验证下。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/WX20210131-145705_ssid.png" srcset="/img/loading.gif" alt="转译字符测试"></p><h3 id="关于中文等非-ascii-字符的支持"><a href="#关于中文等非-ascii-字符的支持" class="headerlink" title="关于中文等非 ascii 字符的支持"></a>关于中文等非 ascii 字符的支持</h3><p>中文及其他非 ascii 字符的其他国家字符所使用的编码格式通常都是兼容 ascii 的，换句话说 ascii 的编码范围 0x0-0x7f 在 GBK、GB232、UTF-8 等编码里依旧是这个范围，不会有其他字符占用这个范围里的编号。因此，只要支持 ascii 字符的解析器，理论上是可以直接支持其他编码格式的文本的。</p><p>虽然解析器可以解析，但是你输入的 ssid 和 pwd 不一定被路由器正确识别！！！</p><p>为什么会这样？原因如下：</p><ol><li><p>用户不知道 路由器 的 ssid 是什么编码格式，通常是 utf-8 编码</p></li><li><p>用户输入的 ssid 编码格式在不同的终端上也不一样，用户自己也不知道</p></li><li><p>如果用户输入的 ssid 编码和 路由器保存的 ssid 编码不一样，那么就连不上了嘛！</p><p> 如果你能连上，说明 Wi-Fi 模块帮你做连转码！</p></li></ol><p>Wi-Fi 模块又是怎么匹配用户输入的 ssid 和 路由器保存的 ssid 编码呢？</p><p>这就要靠 Wi-Fi scan 了，Wi-Fi 扫描的时候会拿到 Wi-Fi 的 ssid 和加密类型等信息，模块就可以通过拿到的 ssid 探测到路由器 ssid 使用的编码格式，然后将用户输入的编码格式转成路由器格式，这样双方的编码格式就匹配了。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/Wi-Fi-ssid-encode-format.png" srcset="/img/loading.gif" alt="编码格式转化演示图"></p><h3 id="另外一个难点——指令和数据混合传输"><a href="#另外一个难点——指令和数据混合传输" class="headerlink" title="另外一个难点——指令和数据混合传输"></a>另外一个难点——指令和数据混合传输</h3><p>除了对特殊格式的 AT 指令解析外，还有一个难点，就是使用 AT 串口进行数据传输（后面简称数传）。AT 指令模块串口的另外一端通常连接着一个 MCU，MCU 通过 AT 串口发送数据给 Wi-Fi 模块，Wi-Fi 模块再发送到网络上；Wi-Fi 模块收到数据后，也是通过 AT 串口发送数据到 MCU。通常，还不仅仅存在一路数据传输，还会有多路数据传输（比如两路 TCP），这个时候怎么管控他们使用 AT 串口呢，以及什么时候发送数据，又什么时候发送 AT 指令呢？</p><p>在 MCU 通过 AT 串口给 Wi-Fi 模块发送数据的时候，乐鑫有两种数传模式：normal 模式 和 passthrough 透传模式。透传模式只支持单个连接。</p><ul><li><p>在 normal 模式下，MCU 需要先告诉对端 Wi-Fi 模块我要发多少数据，然后再发送数据；</p><p>  在 normal 模式下 MCU 使用 <code>AT+CIPSEND=&lt;len&gt;</code> 指令，告诉 Wi-Fi 模块我要发 len 字节数据，请进入 <strong>数据传输模式</strong>，我这个指令后就发数据了。</p></li><li><p>在 透传 模式下，每 20ms 或者每 2048 字节发送一次，哪个方式先到用哪个方式。</p><p>  在透传模式下 MCU 使用 <code>AT+CIPSEND</code> 执行指令，告诉 Wi-Fi 模块我要发数据了，请进入 <strong>数据透传模式</strong>，我这个指令后就发数据了。</p><p>  AT 标准规定从数据透传模式切换到 AT 指令模式需要单独发送一包 <code>+++</code> 的数据，并在紧接着的 1s 内不发送任何内容，这样 AT 解析器就会从数据透传模式切换到 AT 指令模式</p></li></ul><p>在多连接的时候，Wi-Fi 模块还要管理多路连接，乐鑫 提供以下指令来处理：</p><ol><li>使用 CIPMUX 设置是否支持多路连接</li><li>使用 CIPSTART 创建 socket 连接</li><li>使用 CIPSEND 发送 socket 数据（也就是我说的数传）</li><li>支持主动下发数据到对端，也支持被动读取，主动下发使用 +IPD;被动读取使用 CIPRECVLEN 和 CIPRECVDATA。</li><li>使用 CIPCLOSE 关闭连接</li><li>使用 CIPMODE 配置数传模式是 normal 还是 passthrough（透传）模式</li></ol><p>在有多路 socket 链接的时候，数传变得会相对麻烦些，因为多路 socket 可能都在接收数据，每一个 sock 都需要将收到的数据通过 AT 串口传送到对端，串口端还要保证两路数据的独立完整，不能混到一起。这个时候，应该每一路连接都会有一个 receive buff 用来缓存收到的数据（乐鑫默认的 buff 大小是 5744 字节）。所有的 socket 连接可以共用一个 send buff，因为同一时刻只有一个连接使用 AT 串口。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>简单分析了下乐鑫的 AT 指令解析器所做的事情，最近也尝试写了个 AT 指令解析器，感触是非常麻烦，关键是要做很多测试，来检查是否有逻辑问题，各种转译情况的支持问题。</p><p>我看到圈里很多朋友尝试自己写了 console 命令行工具，有朋友感兴趣的话，不妨尝试实现一个 AT 解析器。</p><hr><blockquote><p><strong>如有错误，欢迎指正！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AT 指令</tag>
      
      <tag>乐鑫</tag>
      
      <tag>AT 解析器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐鑫 AT 固件初体验</title>
    <link href="/posts/64d78dda.html"/>
    <url>/posts/64d78dda.html</url>
    
    <content type="html"><![CDATA[<h1 id="乐鑫-AT-固件初体验"><a href="#乐鑫-AT-固件初体验" class="headerlink" title="乐鑫 AT 固件初体验"></a>乐鑫 AT 固件初体验</h1><blockquote><p>查阅官方文档；硬件连接；获取 AT 固件；烧录 AT 固件；体验 AT 指令；</p></blockquote><blockquote><p>前往<a href="https://www.espressif.com/" target="_blank" rel="noopener">乐鑫官网</a> 下载最新版本 AT 固件和 AT 指令集手册。</p></blockquote><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><blockquote><p>本文使用乐鑫的 ESP-WROOM-32（ESP-WROOM-32 是 ESP32-WROOM-32 的曾用名）模块，4MB Flash，无 PSRAM。ESP32 系列模组和开发板参考<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.2/esp32/hw-reference/modules-and-boards.html" target="_blank" rel="noopener">该链接</a>，这里有详细的对比介绍。</p></blockquote><p>模块接线示意图如下：（图片来自<a href="https://docs.espressif.com/projects/esp-at/en/latest/Get_Started/Hardware_connection.html" target="_blank" rel="noopener">乐鑫文档</a>）</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/esp32-wroom-hw-connection.png" srcset="/img/loading.gif" alt="ESP32-WROOM-32 Series Hardware Connection"></p><p>请在<a href="https://docs.espressif.com/projects/esp-at/en/latest/Get_Started/Hardware_connection.html" target="_blank" rel="noopener">该链接</a>里找到你的硬件对应的接线方式，连线必须准确无误！</p><h2 id="选择-AT-固件"><a href="#选择-AT-固件" class="headerlink" title="选择 AT 固件"></a>选择 AT 固件</h2><p>乐鑫的 AT 固件自 V2.0 之后就开始使用 ESP-AT（基于 ESP-IDF 或 ESP8266_RTOS_SDK 实现的软件工程）了，不再使用 NonOS 版本。如果你使用的是 ESP8266 模块，那么可以考虑是否可以平滑升级到新的版本。</p><p>各版本 AT 固件的差异参考该<a href="">链接</a>。</p><p>从<a href="https://docs.espressif.com/projects/esp-at/en/latest/AT_Binary_Lists/index.html" target="_blank" rel="noopener">该链接</a>里选择对应你硬件的 AT 固件，这里我选择 <a href="http://download.espressif.com/esp_at/firmware/ESP32/ESP32_WROOM/ESP32-WROOM-32_AT_Bin_V2.1.0.0.zip" target="_blank" rel="noopener">ESP32 AT binaries / ESP32-WROOM-32 Series / v2.1.0.0 ESP32-WROOM-32_AT_Bin_V2.1.0.0.zip</a>。</p><h2 id="烧录-AT-固件"><a href="#烧录-AT-固件" class="headerlink" title="烧录 AT 固件"></a>烧录 AT 固件</h2><blockquote><p>烧录过程主要参考乐鑫的<a href="https://docs.espressif.com/projects/esp-at/en/latest/Get_Started/Downloading_guide.html" target="_blank" rel="noopener">官方文档</a>，针对我的这个 ESP-WROOM-32 模块，有以下几个步骤：</p></blockquote><ul><li><p>下载 AT 固件到 PC 上（ESP32-WROOM-32_AT_Bin_V2.1.0.0.zip）</p></li><li><p>下载烧录工具</p><p>  烧录工具支持 Windows 和 MAC/Linux 系统，在<a href="https://docs.espressif.com/projects/esp-at/en/latest/Get_Started/Downloading_guide.html" target="_blank" rel="noopener">该链接</a>里下载。</p></li><li><p>正确连接 ESP-WROOM-32 模块到 PC 上</p><p>  ESP-WROOM-32 有两路串口，一路需要使用一个 USB-A 转 Micro-USB 的线，用于固件下载和日志查看；另外一路串口需要一个 USB 转 TTL 串口的模块，用于 AT 指令传输。</p><p>  连线方式见前面的 <code>硬件准备</code> 章节。</p></li><li><p>打开烧录工具，烧录默认 AT 固件</p><ul><li><p>打开工具 <code>flash_download_tool_v3.8.5.exe</code></p></li><li><p>选择 Developer Mode</p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/Download_tool.png" srcset="/img/loading.gif" alt=""></p></li><li><p>选择芯片型号（本文里，我使用 ESP32 DownloadTool）</p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/esp32_wroom32_download_select.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>选择默认 AT 固件，下载到 0x0 地址，并勾选 <code>DoNotChgBin</code></p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124143448.png" srcset="/img/loading.gif" alt=""></p><p>  然后选择对应的 串口 号，波特率使用默认的即可。最后点击 <code>START</code> 开始烧录。</p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124144033.png" srcset="/img/loading.gif" alt=""></p></li><li><p>确认烧录成功（发送 AT 和 AT+GMR 命令确认）</p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124144225.png" srcset="/img/loading.gif" alt=""></p><p>  发 <code>AT</code> 指令返回 OK 标识 AT 服务已经正常启动，发 <code>AT+GMR</code> 查看 AT 固件信息是否跟你烧录的一致。</p></li></ul><h2 id="AT-指令测试-TCP-Server-连接"><a href="#AT-指令测试-TCP-Server-连接" class="headerlink" title="AT 指令测试 TCP Server 连接"></a>AT 指令测试 TCP Server 连接</h2><ol><li><p>确定 WiFi 模块即将连接的路由器</p></li><li><p>将 PC 接入该路由器，保证 WiFi 模块与路由器在同一个局域网下</p></li><li><p>PC 机开启 TCP Server</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124152113.png" srcset="/img/loading.gif" alt=""></p><p> 如上图所示，开启 TCP Server，ip：192.168.50.190 端口：8089。</p></li><li><p>AT 模块连接 AT 串口到 PC，并上电，确定 AT 功能正常</p><p> 发送 AT 返回 OK。</p></li><li><p>设置 AT 模块为 STA 模式（STA 模式下才能连接路由器 AP 热点）</p><p> 发送 <code>AT+CWMODE=1</code> 进入 STA 模式，1 为 STA，2 为 AP，3 为 AP+STA。</p><pre><code> AT+CWMODE=1 OK</code></pre></li><li><p>连接路由器</p><p> 发送 <code>AT+CWJAP=&quot;SSID&quot;,&quot;PWD&quot;</code> 连接路由器，SSID 为路由器 AP 热点名称，PWD 为路由器热点密码。示例如下：</p><pre><code> AT+CWJAP=&quot;murphy&quot;,&quot;pwd_12345678&quot; WIFI CONNECTED WIFI GOT IP OK</code></pre></li><li><p>查询模块 ip 地址，判断是否与 PC 在同一网段下</p><pre><code> AT+CIFSR +CIFSR:STAIP,&quot;192.168.50.15&quot; +CIFSR:STAMAC,&quot;30:ae:a4:04:75:f0&quot; OK</code></pre></li><li><p>连接 TCP Server</p><pre><code> AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.50.190&quot;,8089 CONNECT OK</code></pre><p> 如下图所示，连接成功：</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124153328.png" srcset="/img/loading.gif" alt=""></p></li><li><p>模块发数据给 TCP Server</p><p> 先发送 AT 命令 <code>AT+CIPSEND=x</code>，其中 <code>x</code> 表示要发送的数据长度，告诉 AT 解析器，我要发 x 字节的数据，你准备好接收！</p><p> AT 解析器成功识别之后返回下面信息：</p><pre><code> OK &gt;</code></pre><p> 当看到 <code>&gt;</code> 的时候，我们就可以发数据了，但一定要发送 <code>x</code> 字节数据，否则多余的数据会被丢掉，并返回 <code>busy p...</code>。</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124153703.png" srcset="/img/loading.gif" alt=""></p></li><li><p>TCP Server 发数据给模块</p><p>TCP Server 直接发数据就可以，WiFi 模块收到后，显示 <code>+IPD,x:data</code> 格式的信息。其中 <code>+IPD</code> 表示 WiFi 模块收到了对端的数据，<code>x</code> 表示收到的数据长度，<code>data</code> 表示收到的数据内容。示例如下图所示：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/20210124154510.png" srcset="/img/loading.gif" alt=""></p></li><li><p>模块透传发送数据</p><p>首先设置数传模式为透传模式，指令 <code>AT+CIPMODE=1</code>。1：透传模式；0：普通模式。他们的主要区别是在透传模式可以在 <code>AT+CIPSEND</code> 指令后一直发送数据（直到退出透传发送），而普通模式下每次发送数据必须使用 <code>AT+CIPSEND=x</code> 来指定数据长度。</p><pre><code>AT+CIPMODE=1OKAT+CIPSENDOK&gt;</code></pre><p>这个时候就可以发送数据直达模块了。</p></li><li><p>模块退出透传发送</p><p>发送 <code>+++</code> 后停顿 1 秒。使用串口工具一次性发送 <code>+++</code> 而不是手动一个个发送，否则会导致误检测成数据。</p><p>这是 AT 指令的一个标准约定。</p><p>如果此时想切换成 <em>普通数传模式</em>，发送 <code>AT+CIPMODE=0</code> 指令。</p></li></ol><p>把整个收发过程录了一个视频：</p><iframe src="//player.bilibili.com/player.html?aid=971276668&bvid=BV1hp4y1W7a7&cid=286914407&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>这里给出了乐鑫官网的参考链接，需要阅读原始文档的童鞋移步这里。</p></blockquote><ul><li><p><a href="https://docs.espressif.com/projects/esp-at/zh_CN/latest/Get_Started/index.html" target="_blank" rel="noopener">乐鑫官方 ESP-AT 用户指南</a></p><p>  包括 AT 固件下载，AT 指令集介绍，编译与开发。</p></li><li><p><a href="https://docs.espressif.com/projects/esp-at/en/latest/AT_Binary_Lists/ESP8266_AT_binaries.html" target="_blank" rel="noopener">乐鑫官方 ESP8266 AT 固件</a></p></li><li><p><a href="https://www.espressif.com/zh-hans/support/download/other-tools" target="_blank" rel="noopener">乐鑫工具下载</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AT 指令</tag>
      
      <tag>ESP32</tag>
      
      <tag>乐鑫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT 指令介绍</title>
    <link href="/posts/402d4d22.html"/>
    <url>/posts/402d4d22.html</url>
    
    <content type="html"><![CDATA[<h1 id="AT-指令介绍"><a href="#AT-指令介绍" class="headerlink" title="AT 指令介绍"></a>AT 指令介绍</h1><p>AT（Attention）指令是由 <a href="https://en.wikipedia.org/wiki/Dennis_Hayes_(businessman)" target="_blank" rel="noopener">Dennis Hayes</a> 发明的，所以也称为 <a href="https://en.wikipedia.org/wiki/Hayes_command_set" target="_blank" rel="noopener"><code>Hayes command set</code></a>。AT 指令最初是用来指导 modem 工作的，后面随着技术的发展，低速 modem 已经退出了市场，但 AT 指令却不断发展，并且在今天 AT 指令依旧扮演这非常重要的角色。</p><p>虽然在 PC 端、手机上已经没有了 AT 的使用，但其却在嵌入式行业里各类联网模块中发挥着重要的作用，而且不仅仅只应用在蜂窝模块，还应用到了 WiFi、BLE 等模块中。</p><h2 id="相关标准"><a href="#相关标准" class="headerlink" title="相关标准"></a>相关标准</h2><p>随着技术的发展，目前 AT 指令发展过程中形成两个重要标准：</p><ul><li><p>V.250：该标准于 1995 年建立，1998 年重命名为 V.250</p></li><li><p>ETSI GSM 07.07（3GPP TS 27.007）：用于控制 GSM modem 的 AT 指令集</p><p>  GSM 07.07 是基于 V.250 标准的。是目前最新的 AT 标准。</p></li></ul><h2 id="当下-AT-指令的应用"><a href="#当下-AT-指令的应用" class="headerlink" title="当下 AT 指令的应用"></a>当下 AT 指令的应用</h2><p>目前的 AT 指令着重应用在蜂窝模块、WiFi 模块、BLE 模块中，目的是为了简化嵌入式设备联网的复杂度。</p><p>AT 标准定义了 AT 命令的格式本身，比如命令以 AT 为前缀开头，以 <CR> 或者 <CR><LF> 结尾，这被现有的 AT 模块所延用。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/AT_20210109183018.png" srcset="/img/loading.gif" alt="图片来自 3GPP TS 27.007 V10.7.0 (2012-03)"></p><p>但是，由于每个厂家的模块不一样，实现的功能不一样，导致每个 AT 模块厂家有自己的一套私有的 AT 命令集，每一个 AT 模块厂家实现的 AT 指令集解析器也不一样（解析器实现的 AT 标准功能也参差不齐）。<strong>像上图所示的 AT 命令使用方式不被大多数模块厂家所实现。</strong></p><h2 id="AT-模块的应用框图"><a href="#AT-模块的应用框图" class="headerlink" title="AT 模块的应用框图"></a>AT 模块的应用框图</h2><p>既然是指令集，那么必然会有指令集的解析处理，通常，我们把 AT 模块端的解析处理程序称为 AT Server，而将控制 AT 模块的处理器端的解析处理程序称为 AT Client。由 AT Client 发起命令请求，AT Server 回应处理结果。另外 AT Server 通过 URC（<a href="http://www.itu.int/rec/T-REC-V.25ter-199508-S/en" target="_blank" rel="noopener">Unsolicited result code</a>） 来主动给 AT Client 发送数据。</p><p>应用框图如下所示：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/AT/at_framework.png" srcset="/img/loading.gif" alt=""></p><h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><p>AT 命令的常用格式：</p><pre><code>AT+CMD=&lt;xxx&gt;[,&lt;xxx&gt;,&lt;xxx&gt;]</code></pre><p>AT 指令以 <code>AT</code> 开始，以 <code>\r</code> 或者 <code>\r\n</code> 结尾，参数之间使用 <code>,</code> 隔开，字符串参数使用双引号 <code>&quot;&quot;</code> 包裹，整形参数不适用双引号。</p><ul><li><p><code>&lt;CR&gt;</code>：回车符</p></li><li><p><code>&lt;LF&gt;</code>：换行符</p></li><li><p><code>&lt;xxx&gt;</code></p><p>  尖括号中的名称 <code>xxx</code> 在 AT 里是一个语法元素，要求必须指定。尖括号本身不会出现在命令行里。</p></li><li><p><code>[xxx]</code></p><p>  中括号中的名称 <code>xxx</code> 在 AT 里是一个语法元素，表示可选择指定。中括号本身不出现在命令行里。</p></li></ul><h2 id="四类-AT-命令"><a href="#四类-AT-命令" class="headerlink" title="四类 AT 命令"></a>四类 AT 命令</h2><ul><li><p>Test 命令：<code>AT+&lt;x&gt;=?</code></p><p>  测试指令类似于命令行里的 <code>help</code> 指令，用于提供该命令的使用信息，以及命令参数的取值范围。</p></li><li><p>Read 命令：<code>AT+&lt;x&gt;?</code></p><p>  用于查询该指令对应功能的当前值。</p></li><li><p>Set 命令：<code>AT+&lt;x&gt;=&lt;...&gt;</code></p><p>  设置用户指定的参数到对应的功能里。</p></li><li><p>Execute 命令：<code>AT+&lt;x&gt;</code></p><p>  执行相关操作。</p></li></ul><h2 id="响应结果字符串"><a href="#响应结果字符串" class="headerlink" title="响应结果字符串"></a>响应结果字符串</h2><p>AT 标准定义了标准的响应结果字符串：</p><ul><li><p><code>\r\nOK\r\n</code></p><p>  如果 AT 指令被 AT Server 识别，并正确执行，则返回该结果。</p><blockquote><p>标准中的 V1 模式下响应结果代码的方式。V0 模式下返回 <code>0\r</code>。</p></blockquote></li><li><p><code>\r\nERROR\r\n</code></p><blockquote><p>标准中的 V1 模式下响应结果代码的方式。V0 模式下返回 <code>4\r</code>。</p></blockquote></li></ul><h2 id="数据模式与指令模式"><a href="#数据模式与指令模式" class="headerlink" title="数据模式与指令模式"></a>数据模式与指令模式</h2><p>在收到 <code>+++</code>，并且接下来 1s 内未收到其他数据的话，将从数据模式切换到指令模式。</p><p>数据模式，可以透传数据，client 发什么，server 就原封不动发出去。指令模式时，AT Server 需要解析 AT 指令，并作出响应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Hayes_command_set" target="_blank" rel="noopener">wiki - Hayes command set</a></li><li><a href="https://www.itu.int/rec/T-REC-V.25ter-199508-S" target="_blank" rel="noopener">V.250ter</a></li><li><a href="http://www.arib.or.jp/english/html/overview/doc/STD-T63v9_30/5_Appendix/Rel10/27/27007-a70.pdf" target="_blank" rel="noopener">3GPP TS 27.007</a></li></ul><hr><blockquote><p><strong>如有错误，欢迎指正！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AT 指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言编程规范</title>
    <link href="/posts/f55a6415.html"/>
    <url>/posts/f55a6415.html</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言编程约定"><a href="#C-语言编程约定" class="headerlink" title="C 语言编程约定"></a>C 语言编程约定</h1><blockquote><p>此文为约定，并非完全遵守某个规范，而是由自己的编程习惯总结而来。</p></blockquote><h2 id="文件字符编码"><a href="#文件字符编码" class="headerlink" title="文件字符编码"></a>文件字符编码</h2><blockquote><p>一切的前提。</p></blockquote><p>强烈建议使用 <strong>UTF-8</strong> 编码格式。UTF-8 编码已经广泛应用在 WEB 中，是首选的编码格式。</p><p>UTF-8 编码是 Unicode 标准中的变长编码方式，可以表示 Unicode 中任意一个字符，使用1~4个字节表示字符，且字节顺序无关。统一使用 UTF-8 字符编码可以避免各种乱码问题的出现。</p><p>但是使用 UTF-8 编码格式的目的并不是为了解决乱码问题，而是为了格式的统一，避免在国际化过程中出现乱码而已。另外，不建议在代码里使用<strong>中文</strong>（除非是协议特殊需要传输非 UTF-8 中文字符的情况）。</p><p>在使用各种 IDE 或者文本编辑器的时候，请留意字符编码格式设置，修改成 UTF-8。</p><h2 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h2><p>结论：不建议程序里使用中文，注释也不建议使用中文，独立的文档可以是中文。</p><p>原因：</p><ol><li>文件国际化格式过程中非常容易出现乱码，将乱码转成正常的过程麻烦且耗时，无端增加工作量；</li><li>IDE 支持不友好，比如 keil MDK；</li><li>英文依旧是程序设计的主要语言；</li></ol><h2 id="缩进与-Tab-问题"><a href="#缩进与-Tab-问题" class="headerlink" title="缩进与 Tab 问题"></a>缩进与 Tab 问题</h2><p>在嵌入式 C 编程里，只用 4 个空格进行缩进，<strong>杜绝</strong>使用 <strong>Tab</strong>。</p><p>由于 TAB 控制符在不同的地方其展示宽度不同，尤其是当 TAB 和空格混用的时候，导致代码乱糟糟的。</p><p>建议:</p><p><strong>拒绝使用 TAB，使用 4 个空格代替</strong>，并使用代码格式化工具检查。</p><h2 id="文末空行"><a href="#文末空行" class="headerlink" title="文末空行"></a>文末空行</h2><p>程序文件末尾必须留一行空行。</p><p>因为某些编译器会报警告（如 keil）。</p><h2 id="多余空格和换行问题"><a href="#多余空格和换行问题" class="headerlink" title="多余空格和换行问题"></a>多余空格和换行问题</h2><ul><li>每行末尾不留多余的空格</li><li>空行里不要有空格</li><li>不要留多行空行（不超过 2 行空行）</li></ul><p>建议每一小块代码前后空一行。</p><p><strong>不建议的</strong> 示例代码：</p><pre><code>void main(void)  /* 这里多留了空格 */{  /* 这里多留了空格 */    while(1)    {        /* TODO */    }    /* 这里空了很多行 */}</code></pre><h2 id="回车换行符问题"><a href="#回车换行符问题" class="headerlink" title="回车换行符问题"></a>回车换行符问题</h2><p>请使用 <code>CRLF</code> 也就是 <code>\r\n</code> 进行换行，不要使用独立的 <code>LF</code>。</p><h2 id="函数、变量、文件的命名约定"><a href="#函数、变量、文件的命名约定" class="headerlink" title="函数、变量、文件的命名约定"></a>函数、变量、文件的命名约定</h2><ul><li><p>命名风格</p><p>  个人喜欢 Unix 风格，使用全小写字母加 <code>_</code> 命令，简单直观。</p></li><li><p>全局变量命名</p><p>  关于全局变量，虽不建议全局变量满天飞，但偶尔还是需要定义全局变量的，我习惯将全局变量名以前缀 <code>g_</code> 开头。</p><p>  <code>g_</code> 其实是匈牙利命名法里的，这里沿用的目的是更加醒目地提示变量为全局变量，用的时候需要留意。</p></li><li><p>枚举类型命名</p><p>  枚举元素名全大写，枚举名也建议全大小，枚举元素必须显示给出明确值。</p></li><li><p>typedef 重命名</p><p>  typedef 重命名使用全小写格式，并以 <code>_t</code> 后缀结尾。</p></li><li><p>宏定义全部大写</p></li><li><p>文件、文件夹命名请全部使用小写字母加 <code>_</code> 的方式。</p></li></ul><h2 id="文件头注释"><a href="#文件头注释" class="headerlink" title="文件头注释"></a>文件头注释</h2><p>一个文件的文件头部应该给出文件名、许可信息、更新历史等内容。我常用的格式如下所示：</p><pre><code>/* * Copyright (c) 2021, &lt;这里替换你的邮箱或者公司的名称&gt; * * &lt;这里替换成使用的许可协议&gt; * * Change Logs: * Date           Author       Notes * 2021-01-01     xxx          first version */</code></pre><h2 id="头文件基本格式"><a href="#头文件基本格式" class="headerlink" title="头文件基本格式"></a>头文件基本格式</h2><p>为了避免头文件被重复包含导致各种重定义问题或其他问题，通常头文件格式如下：</p><pre><code>#ifndef __FILE_H__#define __FILE_H__/* 其他内容 */#endif</code></pre><p>通过定义一个宏来避免文件被重复包含。宏的名称需注意格式为全大写，并且是将文件名全大写并前后加两个 <code>_</code> 转变而来。</p><h2 id="C-C-兼容"><a href="#C-C-兼容" class="headerlink" title="C/C++ 兼容"></a>C/C++ 兼容</h2><p>头文件里按照如下方式进行 C/C++ 兼容。</p><pre><code>#if defined(__cplusplus)extern &quot;C&quot; {#endif /* __cplusplus *//* 这里放数据结构和函数原型 */#if defined(__cplusplus)}#endif /* __cplusplus */</code></pre><h2 id="80-线"><a href="#80-线" class="headerlink" title="80 线"></a>80 线</h2><p>可以考虑将每行的字符数量控制在 80 个字符以内。</p><p>出现 80 线受限于当时的计算机技术，电脑昂贵，显示器小，代码通常要打印出来阅读（打印机仅支持 80 列）。但现在的显示器已经不是问题了，还有很多人会配置带鱼屏来阅读代码，所以这条规则可选择应用。</p><p>现在使用 80 线规则有一个好处是可以方便地将两个文件横向并排显示在屏幕上，方便同一个文件前后同时阅读，或者进行文件内容比较。如果你觉得 80 个字符过少，动不动就超过的话，可以考虑 120 线。</p><p>另外，如果一行过长，需要考虑是不是变量名过长、嵌套过深，如果是这样，是时候优化代码啦。如果这些都不是，那么就主动换行以便于阅读。</p><h2 id="不留未用变量"><a href="#不留未用变量" class="headerlink" title="不留未用变量"></a>不留未用变量</h2><p>代码在更新迭代的过程中，难免会遗漏删除不再使用的变量，请<strong>留意编译器警告</strong>，及时清理。</p><p>不留未用变量的目的：一是为了严谨可读；而是为了清除编译器警告。</p><h2 id="重视编译警告"><a href="#重视编译警告" class="headerlink" title="重视编译警告"></a>重视编译警告</h2><blockquote><p>并不是所有的编译器警告都是无关紧要的，<strong>有些警告关乎程序的命运！</strong></p></blockquote><p>示例代码：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20210101225243.png" srcset="/img/loading.gif" alt=""></p><p>上图例子中的警告就是一个严重的错误，而且是一个典型的很难发现的一个手误。如果你没有看警告，没有察觉到这个问题，那代码跑起来，指不定会出什么幺蛾子。</p><p>提示：</p><p>警告，还是能修的都给修了吧，没有坏处。</p><h2 id="注意数据类型的转换"><a href="#注意数据类型的转换" class="headerlink" title="注意数据类型的转换"></a>注意数据类型的转换</h2><p>不匹配的数据类型会导致编译器报警告，警告不能忽视。</p><h2 id="预编译条件注意事项"><a href="#预编译条件注意事项" class="headerlink" title="预编译条件注意事项"></a>预编译条件注意事项</h2><p>预编译要处理的条件，请使用宏定义，不要在预处理条件里写枚举常量。</p><p>因为预编译时，枚举值时恒定的，会导致预编译条件永远成立，参考 <a href="https://blog.csdn.net/Shayne_Lee/article/details/89408942" target="_blank" rel="noopener">CSDN</a>。</p><h2 id="全局变量的使用"><a href="#全局变量的使用" class="headerlink" title="全局变量的使用"></a>全局变量的使用</h2><p>杜绝全局变量满天飞。必须用到全局变量的时候，请务必将其限定在非常小的作用域范围内，能加 static 就加 static，禁止跨文件引用全局变量。</p><p>如需要使用另外一个文件里的全局变量，请在那个文件里加 set、get 接口来引用。</p><h2 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h2><pre><code class="c">typedef struct{    void *arg;} test_struct_t; /* 注意这里 } 后面有一个空格 */if (1 == 1) /* 注意 if 与 &#39;(&#39; 之间有一个空格，元素 &#39;1&#39; 与操作符 &#39;==&#39; 之间有一个空格 */{    /* TODO */}</code></pre><h2 id="花括号-的使用"><a href="#花括号-的使用" class="headerlink" title="花括号 {} 的使用"></a>花括号 <code>{}</code> 的使用</h2><p>有的人喜欢在一行代码的末尾使用 <code>{</code>，而有的人喜欢将 <code>{</code> 和 <code>}</code> 单独占一行，我喜欢后者，原因如下：</p><p>可以方便地注释 <code>{</code> 前面的一行代码而不影响使用，示例如下：</p><pre><code>void main(void){    /* while (1) */    {    }}</code></pre><p>所以为了统一，也建议在定义枚举、结构体的时候也将 <code>{</code> 和 <code>}</code> 单独占一行。</p><h2 id="注释问题"><a href="#注释问题" class="headerlink" title="注释问题"></a>注释问题</h2><p>单行注释请使用这样的形式，避免使用 “//” 形式的注释，因为其实 C++ 类型的注释，某些编译器不支持。</p><p>注释只允许出现在语句的前面和后面。</p><p>函数的注释，重在描述功能和注意事项。</p><pre><code class="c">/* 注释内容与注释标记之间需要留一个空格，像这样 *//* API 的注释，示例如下 *//*** test_func* * @brief Test function. Used to show the name and age.* * @param name Input param, Specify user name.* @param age  Input param, Specify user age.* * @return void* */void test_func(const char *name, uint8_t age);</code></pre><h2 id="if-0-或-if-1-或成片的代码注释"><a href="#if-0-或-if-1-或成片的代码注释" class="headerlink" title="#if 0 或 #if 1 或成片的代码注释"></a><code>#if 0</code> 或 <code>#if 1</code> 或成片的代码注释</h2><p>结论：不建议使用。</p><p>如果是测试用途或者其他用途，一定要注释说明这么写的原因，以及是否可以移除或者修改。</p><p>如果是遗弃代码，请明显标识遗弃字样，并给出替代接口，或者给出遗弃原因。</p><h2 id="bool-类型使用问题"><a href="#bool-类型使用问题" class="headerlink" title="bool 类型使用问题"></a>bool 类型使用问题</h2><p><del>不建议使用 bool 类型。</del></p><p><strong>bool 类型的背景：</strong></p><p>C89 没有定义布尔类型，如果你使用 true 和 false，会出现错误。C99 提供了一个头文件 &lt;stdbool.h&gt; 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。只要导入 <code>stdbool.h</code>，就可以使用布尔类型了。</p><p>由于这个历史原因，导致一些代码模块会自定义 bool 类型，也自定义类似 TRUE 和 FALSE 这样的宏。</p><p>C 标准并没有定义 bool 类型的具体类型，也没有指定 bool 类型的类型大小，不同的 C 标准库对 bool 类型的大小定义不同。</p><p>建议使用 &lt;stdint.h&gt; 中的数据类型，<del>同时避免使用 bool 类型</del>要注意 bool 类型的使用注意事项。</p><p><strong>bool 类型使用的注意事项：</strong></p><p>条件表达式里，bool 类型不能和 true 进行比较。</p><p>C99 里定义了 true 和 false，但是只认 false（也就是 0）为唯一有效值，所以 true 是不确定的，不能用在条件表达式里进行比较。</p><p>也就是 bool 类型只允许以下比较情况：</p><pre><code>if (xxxx)if (!xxxxx)if (false == xxxxx)if (false != xxxxx)</code></pre><p>唯独 <code>if (true == xxxxx) 和 if (true!= xxxxx)</code> 不行。</p><p>如果需要定义 bool 类型的话，如下定义：</p><pre><code>typedef enum{    false = 0,    true  = !false} bool;</code></pre><h2 id="使用标准数据类型"><a href="#使用标准数据类型" class="headerlink" title="使用标准数据类型"></a>使用标准数据类型</h2><p>基本数据类型，除非设计不同平台 size 不同的情况，请直接用 C99 &lt;stdint.h&gt; 中定义的标准数据类型（int8_t、uint8_t 等）。而不是使用自行定义的 u8、u16 这些类型。</p><h2 id="枚举定义问题"><a href="#枚举定义问题" class="headerlink" title="枚举定义问题"></a>枚举定义问题</h2><p>定义一定赋初值。</p><p>枚举的大小也不是恒定的，根编译器有关。在配合结构体使用时请注意不要随便使用相对结构体指针的偏移量来读取数据成员的值。</p><h2 id="仔细检查-return-和-goto"><a href="#仔细检查-return-和-goto" class="headerlink" title="仔细检查 return 和 goto"></a>仔细检查 <code>return</code> 和 <code>goto</code></h2><p>主要为了留意是否会有内存泄漏，或者使用了未初始化的变量。</p><h2 id="引入的第三方模块带来的格式问题"><a href="#引入的第三方模块带来的格式问题" class="headerlink" title="引入的第三方模块带来的格式问题"></a>引入的第三方模块带来的格式问题</h2><p>如果你的项目里引入了第三方模块，但是第三方模块跟你项目的代码风格不一致，这个时候怎么做呢？</p><p>为了方便日后更新维护，建议保留其原来的文件格式，不做任何修改（一个好的模块，也基本不需要做修改）。</p><p>如果必须要修改第三方模块的代码，视情况转化为统一的风格，轻改动风格不变，重改动统一风格（既然是重改动，肯定需要自己维护这套代码）。</p><p><strong>注意在版权范围内引入和修改第三方代码。</strong></p><h2 id="中文文档排版规范"><a href="#中文文档排版规范" class="headerlink" title="中文文档排版规范"></a>中文文档排版规范</h2><p>参考 <a href="https://github.com/iot-preschool/chinese-copywriting-guidelines/blob/master/README.zh-CN.md" target="_blank" rel="noopener">中文文案排版指北</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>仅站在巨人的肩膀上做了些许的总结，向他们致敬！</p></blockquote><ul><li><p><a href="https://github.com/RT-Thread/rt-thread/blob/master/documentation/coding_style_cn.md" target="_blank" rel="noopener">RT-Thread 代码规范</a></p><p>  受 RT-Thread 编程风格影响很大。</p></li><li><p><a href="https://www.misra.org.uk/" target="_blank" rel="noopener">MISRA-C 官网</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/295299549" target="_blank" rel="noopener">知乎-szyyy-MISRA C标准</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同一客户端下使用多个 Git 账户</title>
    <link href="/posts/75c2b6d7.html"/>
    <url>/posts/75c2b6d7.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><h3 id="为什么会有多个-Git-账户"><a href="#为什么会有多个-Git-账户" class="headerlink" title="为什么会有多个 Git 账户"></a>为什么会有多个 Git 账户</h3><p>当下环境做软件开发或多或少都离不开资源丰富的 GitHub，它并誉为程序员的天堂，几乎每一个软件开发人员都会有一个自己的 GitHub 账户。</p><p>另一方面，软件公司也在不断进化代码的管理方式，大多数软件公司开始独立部署私有的 Gitlab 来托管公司代码，进而进行工程管理和代码审查，以及后续的自动化部署、自动化测试、持续集成。所以，你至少还会有一个公司的 Git 账户。</p><p>再者，由于 GitHub 属于外网，经常被 Q 而无法高效率地使用，所以我们还经常会用到国内越来越好的 Git 托管平台 <a href="https://gitee.com/" target="_blank" rel="noopener">码云 Gitee</a>，而且很多国内优秀的开源软件会将同步托管到 GitHub 和 Gitee，国内的开发者可以使用 Gitee 优雅地拉取和推送代码，而不用担心龟速下载的问题。另外，Gitee 还有一个非常重要的中间人的角色，当 GitHub 资源下载不动时，你可以将其导入到 Gitee，从 Gitee 上下载代码，然后再通过设置 remote 的方式回溯到 GitHub。因此，怎么样你都还得有一个 Gitee 账户。</p><p>So，现在我们已经有了三个 Git 账户了（GitHub、公司 Gitlab、Gitee），需要在一台 PC 终端上使用。</p><h3 id="多个账户会带来什么问题"><a href="#多个账户会带来什么问题" class="headerlink" title="多个账户会带来什么问题"></a>多个账户会带来什么问题</h3><blockquote><p>既然你已经翻到了这篇文章，想必你已经遇到了问题。</p><p>没遇到问题的朋友，不妨使用常用的 HTTPS 方式在同一个 PC 终端操作不同账户试试，看看会遇到哪些问题（基本上都是修改了 name 和 email 还是无法推送代码，提示禁止访问，苦笑）。</p></blockquote><p>如果遇到账户名密码不对的情况，也可以尝试去 Windows 的凭据中心删除对应的账户凭据，重新配置，位置 “控制面板 –&gt; 凭据管理器 –&gt; Windows 凭据”。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p><strong>使用 SSH</strong>。</p></blockquote><p>SSH 是另外一种加密传输方式，采用公钥+私钥的方式来验证用户的合法性，Git 托管平台基本都支持 SSH 方式访问，我们需要做的就是为各个平台配置对应的公钥。</p><h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><blockquote><p>前提：你的 PC 机已经安装了 <a href="https://git-scm.com/" target="_blank" rel="noopener">git-scm 工具</a>，没有安装的点击链接安装，我们需要使用其 <code>Git Bash</code>。</p></blockquote><ol><li><p>任意目录下打开 <code>Git Bash</code> 工具</p></li><li><p>输入命令以下命令</p><pre><code class="shell"> $ ssh-keygen -t rsa -C &#39;youremail@xxx.com&#39; -f ~/.ssh/xxx_id_rsa</code></pre><p> 其中 <code>-C</code> 后面指定的邮箱是 SSHKEY 的名称，为了便于辨识建议使用个人邮箱标识；<code>-f</code> 后面的 <code>~/.ssh/xxx_id_rsa</code> 是指定生成的 SSH KEY 文件的路径名称，建议命名 xxx_id_rsa 的时候加上代码托管平台的标识，便于后续区分，比如 <code>github_id_rsa</code> 和 <code>gitee_id_rsa</code>，如果你一个平台有多个账号，那最好也把用户名指定上去，如 <code>gitee_username_id_rsa</code>。</p></li><li><p>输入命令后回车，然后按照默认，依次输入三次回车，既可生成 SSH KEY，如下所示：</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913181049.png" srcset="/img/loading.gif" alt=""></p></li><li><p>安装上面相同的方式，生成其它平台的 SSH KEY，比如 gitee 和 gitlab</p></li><li><p>查看生成的文件</p><pre><code> $ ls ~/.ssh gitee_xxx_id_rsa      github_xxx_id_rsa      gitlab_work_id_rsa gitee_xxx_id_rsa.pub  github_xxx_id_rsa.pub  gitlab_work_id_rsa.pub</code></pre></li></ol><h3 id="部署公钥"><a href="#部署公钥" class="headerlink" title="部署公钥"></a>部署公钥</h3><ol><li><p>查看对应平台的公钥，<code>.pub</code> 后缀的文件为公钥，举例 github_xxx_id_rsa.pub</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913181856.png" srcset="/img/loading.gif" alt=""></p></li><li><p>复制展示出来的公钥内容，从 ssh-rsa 开始（包括 ssh-rsa）直到末尾，包括末尾的“邮箱”或者在第二步骤中 -C 设置的其他名称。</p></li><li><p>浏览器打开 GitHub，添加公钥</p><p> 直达链接：<a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a> ，然后选择 <code>New SSH key</code>。</p><p> <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913182423.png" srcset="/img/loading.gif" alt=""></p><p> 注，这里的 Title 也是为了提示你这个 SSH key 是用来做什么的，因此要能给你提示，<strong>建议以你的 PC 机名字命名</strong>。</p></li><li><p>然后同样的方式，把其他平台的 <code>.pub</code> 公钥部署到对应的托管平台。</p></li></ol><h3 id="在-ssh-目录增加配置-config-文件"><a href="#在-ssh-目录增加配置-config-文件" class="headerlink" title="在 ~/.ssh 目录增加配置 config 文件"></a>在 ~/.ssh 目录增加配置 config 文件</h3><p>在 <code>~/.ssh</code> ，内容如下：</p><pre><code># giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_xxx_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_xxx_id_rsa</code></pre><p>其中 Host 和 HostName 填写 git 服务器的域名，IdentityFile 指定私钥的路径。如果你还有其他的代码服务器，可以继续追加配置。</p><p>Git bash 工具支持 vim 命令编辑文件，<code>vim ~/.ssh/config</code> 填写配置，然后保存。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>ssh -T host</code> 命令进行分别测试</p><pre><code>$ ssh -T git@github.com测试成功后，再测试其他平台：$ ssh -T git@gitee.com</code></pre><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913184237.png" srcset="/img/loading.gif" alt=""><br><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913193320.png" srcset="/img/loading.gif" alt=""></p><p>测试通过后，您就可以愉快地使用 SSH 的方式进行 clone 和 push 了，如下所示：</p><pre><code>git clone git@gitee.com:xxx/xxx.git</code></pre><h3 id="小乌龟-Git-工具适配"><a href="#小乌龟-Git-工具适配" class="headerlink" title="小乌龟 Git 工具适配"></a>小乌龟 Git 工具适配</h3><p>除了 <a href="https://git-scm.com/" target="_blank" rel="noopener">git-scm</a> 命令行工具外，我们还常用 <a href="https://tortoisegit.org/" target="_blank" rel="noopener">TortoiseGit</a> 可视化工具来配合工作，该工具乌龟 logo，故该工具俗称 <em>“小乌龟”</em>。</p><p>由于 <a href="https://tortoisegit.org/" target="_blank" rel="noopener">TortoiseGit</a> 使用的 SSH 秘钥与 ssh-keygen 不同，所以使用 TortoiseGit 的时候依旧会提示 <code>NotSupport</code>。所以我们需要对 TortoiseGit 的 SSH 工具进行修改。错误提示通常如下：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/gitee-not-supportkeys.png" srcset="/img/loading.gif" alt=""></p><p>打开 TortoiseGit 配置，选择 <strong>Network</strong> –&gt; <strong>SSH</strong>，调整原来的 <code>TortoiseGitPlink.ese</code> 为 <code>git-scm</code> 工具的 <code>ssh.exe</code>，如下图所示：</p><p>TortoiseGit 原来的配置：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913194401.png" srcset="/img/loading.gif" alt=""></p><p>TortoiseGit 修改为 ssh.exe 后的配置：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200913194452.png" srcset="/img/loading.gif" alt=""></p><hr><p>好了，到此为止，同一客户端下可以愉快地使用多个 Git 账户了，再也不用担心账户密码冲突的问题了，也不用担心每次都要输入密码的问题。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TortoiseGit</tag>
      
      <tag>小乌龟</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Markdown 的中文文档排版规范</title>
    <link href="/posts/eaf5273.html"/>
    <url>/posts/eaf5273.html</url>
    
    <content type="html"><![CDATA[<p>本篇文章先介绍 Markdown 的背景信息，然后着重介绍 Markdown 中文文档的排版规范，不介绍 Markdown 的入门使用。</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>相信阅读本文的读者一定有被 Markdown 灵活的写作风格搞懵过，不知道怎么写更优雅、更规范，那么本文就是来帮您梳理 Markdown 写作过程中常见的一些问题，然后给出一个建议的应用规范。</p><p>通过阅读本文，相信你一定可以基于 Markdown 写出更加优雅的中文文档。</p><h2 id="1-关于-Markdown"><a href="#1-关于-Markdown" class="headerlink" title="1 关于 Markdown"></a>1 关于 Markdown</h2><p>Markdown 是由 <a href="https://en.wikipedia.org/wiki/John_Gruber" target="_blank" rel="noopener">John Gruber</a> 于 2004 年创建的一种文本标记语言，目的是让人们使用“直观的、便于阅读的纯文本格式”书写文档。</p><p>与类似于 HTML 标记语言用于展示网页不同，Markdown 被设计用来 <strong>专注于文本写作</strong>；与 word 不同，Markdown 只有输入文本字符，没有复杂的格式控制，Markdown 仅通过数个文本标记符来实现简单的格式控制，让写作回归写作。</p><h2 id="2-Markdown-语法规范"><a href="#2-Markdown-语法规范" class="headerlink" title="2 Markdown 语法规范"></a>2 Markdown 语法规范</h2><p>Markdown 设计之初没有明确的语法规范，随着 Markdown 被更多的人使用，这种不规范直接导致了多种 Markdown 语法的变体，Markdown 解析器也变得混乱，无法统一。</p><p>开源平台 GitHub 做为 Markdown 文档的直接支持者已经无法忍受这种情况，2017 年 GitHub 发布了 Markdown <strong>GFM</strong>（GitHub Flavored Markdown） 标准规范，并且修改了 GitHub 的 Markdown 解析器以规范用户行为。</p><blockquote><p>GitHub 在 <a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GFM 规范</a>中详细阐述了为什么需要规范 Markdown 语法，有兴趣的读者可以详细阅读。</p></blockquote><p><strong>重点</strong>：</p><p><strong>推荐使用 <a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub GFM</a> 规范！</strong></p><h2 id="3-中文文档排版规范"><a href="#3-中文文档排版规范" class="headerlink" title="3 中文文档排版规范"></a>3 中文文档排版规范</h2><h3 id="3-1-语法规范建议"><a href="#3-1-语法规范建议" class="headerlink" title="3.1 语法规范建议"></a>3.1 语法规范建议</h3><p><strong>推荐使用 <a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub GFM</a> 规范！</strong> 其他规范不做介绍。</p><h3 id="3-2-标题格式建议"><a href="#3-2-标题格式建议" class="headerlink" title="3.2 标题格式建议"></a>3.2 标题格式建议</h3><p><a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub GFM</a> 规范支持 <a href="https://github.github.com/gfm/#atx-headings" target="_blank" rel="noopener"><strong>ATX 标题</strong></a> 和 <a href="https://github.github.com/gfm/#setext-heading" target="_blank" rel="noopener"><strong>Setext 标题</strong></a> 规范，<strong>推荐使用 <a href="https://github.github.com/gfm/#atx-headings" target="_blank" rel="noopener">ATX 标题</a> 规范</strong>，最大支持 6 级标题。</p><p><a href="https://github.github.com/gfm/#atx-headings" target="_blank" rel="noopener"><strong>ATX 标题</strong></a> 标题规范示例：</p><pre><code># 一级标题## 二级标题### 三级标题</code></pre><h3 id="3-3-空行"><a href="#3-3-空行" class="headerlink" title="3.3 空行"></a>3.3 空行</h3><ul><li><p>不要有多余的空行</p><p>  在 Markdown 文本中，想要做到渲染后 <strong>真换行</strong> 通常是使用两个空格加一个回车换行符（Unix 下只有回车 CR），或者粗暴地空一行，但是 <strong>请不要连续空两行及以上</strong>。</p></li><li><p>文件末尾空一行</p><p>  强烈建议文件末尾空一行，大多数格式检查工具都会检查文件末尾的空行。文件末尾增加空行的可能原因是为了方便进行文件拼接处理。</p></li><li><p>标题前后各空一行</p></li></ul><h3 id="3-4-空格"><a href="#3-4-空格" class="headerlink" title="3.4 空格"></a>3.4 空格</h3><blockquote><p><strong>重中之重</strong>，希望严格对待。</p></blockquote><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p><p>与大家共勉之。」——<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></p><h4 id="3-4-1-中英文之间需要增加空格"><a href="#3-4-1-中英文之间需要增加空格" class="headerlink" title="3.4.1 中英文之间需要增加空格"></a>3.4.1 中英文之间需要增加空格</h4><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h4 id="3-4-2-中文与数字之间需要增加空格"><a href="#3-4-2-中文与数字之间需要增加空格" class="headerlink" title="3.4.2 中文与数字之间需要增加空格"></a>3.4.2 中文与数字之间需要增加空格</h4><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h4 id="3-4-3-数字与单位之间需要增加空格"><a href="#3-4-3-数字与单位之间需要增加空格" class="headerlink" title="3.4.3 数字与单位之间需要增加空格"></a>3.4.3 数字与单位之间需要增加空格</h4><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h4 id="3-4-4-全角标点与其他字符之间不加空格"><a href="#3-4-4-全角标点与其他字符之间不加空格" class="headerlink" title="3.4.4 全角标点与其他字符之间不加空格"></a>3.4.4 全角标点与其他字符之间不加空格</h4><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h2 id="4-标点符号"><a href="#4-标点符号" class="headerlink" title="4 标点符号"></a>4 标点符号</h2><h3 id="4-1-不重复使用标点符号"><a href="#4-1-不重复使用标点符号" class="headerlink" title="4.1 不重复使用标点符号"></a>4.1 不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="5-全角和半角"><a href="#5-全角和半角" class="headerlink" title="5 全角和半角"></a>5 全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全形和半形</a>』。</p><h3 id="5-1-使用全角中文标点"><a href="#5-1-使用全角中文标点" class="headerlink" title="5.1 使用全角中文标点"></a>5.1 使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="5-2-数字使用半角字符"><a href="#5-2-数字使用半角字符" class="headerlink" title="5.2 数字使用半角字符"></a>5.2 数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="5-3-遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#5-3-遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="5.3 遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>5.3 遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="6-名词"><a href="#6-名词" class="headerlink" title="6 名词"></a>6 名词</h2><h3 id="6-1-专有名词使用正确的大小写"><a href="#6-1-专有名词使用正确的大小写" class="headerlink" title="6.1 专有名词使用正确的大小写"></a>6.1 专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="6-2-不要使用不地道的缩写"><a href="#6-2-不要使用不地道的缩写" class="headerlink" title="6.2 不要使用不地道的缩写"></a>6.2 不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="7-有争议的点"><a href="#7-有争议的点" class="headerlink" title="7 有争议的点"></a>7 有争议的点</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是 <strong>正确</strong> 的。</p><h3 id="7-1-链接之间增加空格"><a href="#7-1-链接之间增加空格" class="headerlink" title="7.1 链接之间增加空格"></a>7.1 链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="7-2-加粗、斜体、高亮文本前后加空格"><a href="#7-2-加粗、斜体、高亮文本前后加空格" class="headerlink" title="7.2 加粗、斜体、高亮文本前后加空格"></a>7.2 加粗、斜体、高亮文本前后加空格</h3><p>建议在 <strong>加粗</strong>、<strong>斜体</strong>、<strong>高亮文本</strong> 前后加空格，否则某种情况会出现格式解析失败。</p><p>建议用法：</p><blockquote><p>修复了一个 <strong>内存泄露</strong> 问题，该问题由 <em>someone</em> 在 <code>版本 v0.1.1</code> 中引入。</p><p><strong>测试文本</strong>，这是测试。</p></blockquote><p>不建议用法：</p><blockquote><p>修复了一个<strong>内存泄露</strong>问题，该问题由<em>someone</em>在<code>版本 v0.1.1</code>中引入。</p><p><strong>测试文本</strong> ，这是测试。</p></blockquote><p>解析失败的情况：</p><blockquote><p>这是一个解析失败的情况，当引用了一个函数<strong>void main(void)</strong>的情况下，如果没有在加粗文本前后增加空格，会导致格式解析失败。<strong>这种情况在 GitHub 中存在</strong>。</p></blockquote><h3 id="7-3-列表缩进"><a href="#7-3-列表缩进" class="headerlink" title="7.3 列表缩进"></a>7.3 列表缩进</h3><p>建议使用 4 个空格进行文本缩进，尤其是遇到有序列表或者无序列表的时候。另外，在使用无序列表或者有序列表的时候，建议在上下级之间空一行，同级之间可以不空行。</p><p>示例：</p><ul><li><p>一级</p><ul><li>二级</li></ul></li><li><p>一级</p><ul><li>二级</li><li>二级</li></ul></li><li><p>一级</p><ul><li><p>二级</p><ul><li>三级</li></ul></li><li><p>二级</p><ul><li>三级</li><li>三级</li></ul></li></ul></li></ul><h3 id="7-4-的使用"><a href="#7-4-的使用" class="headerlink" title="7.4 / 的使用"></a>7.4 <code>/</code> 的使用</h3><p>建议 <code>/</code> 字符前后留空格，充当路径描述符的时候除外。</p><h3 id="7-5-简体中文使用直角引号"><a href="#7-5-简体中文使用直角引号" class="headerlink" title="7.5 简体中文使用直角引号"></a>7.5 简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><h2 id="8-谁在这样做？"><a href="#8-谁在这样做？" class="headerlink" title="8 谁在这样做？"></a>8 谁在这样做？</h2><table><thead><tr><th>网站</th><th>文案</th><th>UGC</th></tr></thead><tbody><tr><td><a href="https://www.apple.com/cn/" target="_blank" rel="noopener">Apple 中国</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/hk/" target="_blank" rel="noopener">Apple 香港</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/tw/" target="_blank" rel="noopener">Apple 台湾</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-cn/" target="_blank" rel="noopener">Microsoft 中国</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-hk/" target="_blank" rel="noopener">Microsoft 香港</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-tw/" target="_blank" rel="noopener">Microsoft 台湾</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a></td><td>是</td><td>是</td></tr><tr><td><a href="https://apple4us.com/" target="_blank" rel="noopener">Apple4us</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://ruby-china.org/" target="_blank" rel="noopener">Ruby China</a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://phphub.org/" target="_blank" rel="noopener">PHPHub</a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://sspai.com/" target="_blank" rel="noopener">少数派</a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.espressif.com/zh-hans" target="_blank" rel="noopener">乐鑫</a></td><td>是</td><td>是</td></tr></tbody></table><h2 id="9-工具推荐"><a href="#9-工具推荐" class="headerlink" title="9 工具推荐"></a>9 工具推荐</h2><p>Markdown 实时编辑实时渲染工具推荐以下两个：</p><ul><li>Typora</li><li>vscode</li></ul><h2 id="10-参考"><a href="#10-参考" class="headerlink" title="10 参考"></a>10 参考</h2><ul><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a></li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北-修改版</a></li><li><a href="https://sspai.com/post/54912" target="_blank" rel="noopener">Typora 完全使用详解</a></li></ul><hr><blockquote><p>我结合 <a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a> 一文和自己的应用经验汇总输出了 <a href="https://github.com/iot-preschool/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北-修改版</a>，本文是基于该修改版本。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>中文文档排版规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Equifax 信息泄露始末笔记</title>
    <link href="/posts/dc4756e2.html"/>
    <url>/posts/dc4756e2.html</url>
    
    <content type="html"><![CDATA[<h2 id="Equifax-信息泄露始末笔记"><a href="#Equifax-信息泄露始末笔记" class="headerlink" title="Equifax 信息泄露始末笔记"></a>Equifax 信息泄露始末笔记</h2><ol start="0"><li><p>代码设计的时候就应该将安全考虑进去</p></li><li><p>接口设计应符合安全规范，慎重设计使用能够执行系统命令的接口</p></li><li><p>使用开源软件必须密切关注开源软件动态，尤其留意 bug 的暴露与修复</p></li><li><p>开源软件选择需谨慎，安全因素需考虑</p></li><li><p>培养安全意识，定义安全规范，建立安全理论知识体系</p><p> 一定要培养员工的安全意识，员工计算机水平参差不齐，很有可能成为钓鱼入口。</p></li><li><p>注重代码审查，以及代码入库审查</p><p> 很多已经入库的代码竟然存在服务器的账户名和密码！GitHub 上现在也还有很多这样的仓库。</p></li><li><p>留意日志组件可能泄露隐私数据</p></li><li><p>谨防钓鱼攻击</p><p> 陌生邮件、可疑邮件不要轻易打开其中的附件，更不要轻易付款或授权。</p></li><li><p>安全备份方案，不要仅有一层安全防护</p></li><li><p>不要使用弱密码</p></li><li><p>不要明文保存密码</p><p>一定要保存密码的散列值如 SHA-256，不要使用已知的被攻破的算法（如 MD5，如撞库）。另外，需要使用安全随机数作为 salt，这样避免被通过彩虹表反查出明文。最后，不同网站建议使用不同的密码。</p></li></ol><p>为了避免被攻击，Apache Struts 的副总裁雷内·吉伦（René Gielen）在 Apache 软件基金会的官方博客中提出了 5 条最佳实践（遵循规范），整理如下：</p><ol><li>完全掌控产品软件用了哪些外部软件，他们的版本是多少，并时刻跟踪这些软件的公开信息和安全生命，及时修复问题版本</li><li>建立外部软件版本更新导致产品软件重新发布的工作流（Murphy 建议最好使用 CI 自动化，避免人的操作失误），这样可以快速发布修复漏洞后的版本</li><li>建立安全策略的前提是“所有复杂的软件都有漏洞”，策略需严谨</li><li>建立多个安全层，这是一种良好的软件工程实践</li><li>建立异常访问的监控机制，监测到异常及时发出警报，这样可以将影响降低</li></ol><p>另外，外加一条软件工程的最佳实践，<strong>足够多和全的测试</strong>。理论上，覆盖测试、单元测试都需要做，而且需要结合自动化测试工具使用 CI 进行每次代码提交的测试，每次版本输出的测试。单元测试必须严谨全面。</p><p>最后，左耳朵耗子还提到了自己的经验，“防家贼”。将关键的数据定义出来，把这些数据隔离开，放到安全级别非常高的地方（有各种安全审计、安全监控、安全访问的区域）。还有，这些关键数据或者敏感数据接触的人越少越好，最好是不暴露给公司内部员工直接存储。在加密上，要使用非对称加密，要使用动态秘钥。</p><p>安全是非常严肃的事情，必须加强安全意识，注重安全防范。国家在安全等级保护制度中也明确了企业机构有责任和义务保证用户数据安全，安全无小事，需要防范于未然。</p><blockquote><p>以上内容来自极客时间“左耳听风-陈皓”专栏的学习总结，该专栏内容非常专业实用，需要细品多遍，欢迎各位读者去陈皓专栏订阅，本篇笔记如有侵权，请联系删除，谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>左耳朵耗子</tag>
      
      <tag>陈皓</tag>
      
      <tag>极客时间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术手艺人如何更值钱</title>
    <link href="/posts/18e85c28.html"/>
    <url>/posts/18e85c28.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>程序员如何用技术变现笔记学习笔记。</p></blockquote><p>这篇文章是非常有用的经验之谈，都是干货，需要结合自己的情况，不断品味里面的道理，然后指导自己做正确的决定。</p><p>引用浩哥文章的一段话：</p><blockquote><p>程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门“手艺活儿”，那么作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。当然，有手艺的人就能做出别人做不出来的东西，而付费也是一件很自然的事了。我们所要做的就是让自己的“手艺”更加值钱。</p></blockquote><h2 id="有意识，懂大道理"><a href="#有意识，懂大道理" class="headerlink" title="有意识，懂大道理"></a>有意识，懂大道理</h2><ol><li>意识到自己的价值</li><li>努力做到“我完全可以靠自己的手艺、不依赖任何人或公司去生活”</li><li>我完全没有必要通过打工听人安排而活着，而是<strong>反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活</strong>；</li><li>对于重复的工作，要想尽办法提高效率，节省自己的时间用在更重要的事情上</li></ol><p>如果想成为手艺人，让自己的手艺变现，需要明白一些道理，皓哥给出了自己的总结：</p><ol><li>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。</li><li>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。</li><li>更重要的是，技术和知识完全是可以变现的。</li><li>25~35 岁是每个人最宝贵的时光，应该用在刀刃上。</li></ol><blockquote><p><strong>25~35 岁是每个人最宝贵的时光，应该用在刀刃上。</strong> 共勉。</p></blockquote><h2 id="技术手艺人的重点特性"><a href="#技术手艺人的重点特性" class="headerlink" title="技术手艺人的重点特性"></a>技术手艺人的重点特性</h2><p>作为技术手艺人，总结几点：</p><ol><li><p>技术和技能的领先</p></li><li><p>对技术本质和趋势的敏感度</p></li><li><p>多去前沿的公司经历和学习这些东西</p></li><li><p>多分享，多交流</p><p> 不同思想，不同的思维方式，在一起碰撞能够更加丰富自己的认知，改善自己的思考方式，扩大思考的角度，提高认知的高度，开阔自己的视野。</p></li></ol><blockquote><p><strong>并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重。</strong></p></blockquote><h2 id="如何让自己的手艺更加值钱"><a href="#如何让自己的手艺更加值钱" class="headerlink" title="如何让自己的手艺更加值钱"></a>如何让自己的手艺更加值钱</h2><p>手艺更加值钱，变现也更加容易和自然，可能都不需要你自己张罗。</p><ol><li><p>千里之行，积于跬步。你得确保你有一个一个的小成功。</p><p> 做到让别人有求于你，或者向别人推荐你。只有掌握大多数人不能掌握的技术，有更多别人没有的经验和经历，你的影响力和个人品牌才会发光发亮，这需要你更多地学习。</p><p> 别人需要你的帮助，你的帮助有效果，那就会产生效益，会为你拓展更大的空间。</p></li><li><p>关注有价值的东西</p><p> 调研技术市场，关注技术趋势，找到并掌握符合未来发展的技术，你就有了先发优势。符合未来发展趋势的技术，其背后一定会有大型商业公司的支持，这类公司越多，该技术就越需要关注。</p></li><li><p>找到能体现价值的地方。在一家高速发展的公司中，技术人员的价值可以达到最大化。</p><p> 比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。</p></li><li><p>动手能力很重要。理论和思考要能落地，要通过不断动手操作才能知晓技术细节，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案。</p></li><li><p>关注技术付费点。愿意技术付费有两个点：一个是，能帮别人“挣钱”的地方；另一个是，能帮别人“省钱”的地方。</p></li><li><p>提高自己的能力和经历。付费的前提是信任，只有不断提过自己的能力和经历，才会被人可以，被信任，被靠谱。</p></li><li><p>找到有价值的信息源，远离微信朋友圈的低质量信息。多从源头解决问题，善用 Google。</p></li><li><p>输出观点和价值观。唯有输出才能让更多的人注意到你，然后才会有影响力。</p></li><li><p>优质的朋友圈。</p></li></ol><h2 id="优质的朋友圈共性"><a href="#优质的朋友圈共性" class="headerlink" title="优质的朋友圈共性"></a>优质的朋友圈共性</h2><ul><li>这些人都比较有想法、有观点，经验也比较丰富；</li><li>这些人涉猎的面比较广；这些人都有或多或少的成功；</li><li>这些人都是喜欢折腾喜欢搞事的人；</li><li>这些人都对现状有些不满，并想做一些改变；</li><li>这些人都有一定的影响力。</li></ul><h2 id="有思想地学习技术"><a href="#有思想地学习技术" class="headerlink" title="有思想地学习技术"></a>有思想地学习技术</h2><ol><li>这个技术解决什么问题？为什么同类技术做不到？</li><li>为什么是这样解决的？有没有更好的方式？</li></ol><h2 id="皓哥总结"><a href="#皓哥总结" class="headerlink" title="皓哥总结"></a>皓哥总结</h2><p>总之，就一句话，<strong>会挣钱的人一定是会投资的人</strong>。我一直认为，最宝贵的财富并不是钱，而是你的时间，<strong>时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了</strong>。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。</p><hr><p><strong>这篇文章干货超级多，建议读者直接去订阅陈皓在极客时间的专栏学习，反复品读，反复品读！</strong></p><blockquote><p>以上内容来自极客时间“左耳听风-陈皓”专栏的学习总结，该专栏内容非常专业实用，需要细品多遍，欢迎各位读者去陈皓专栏订阅，本篇笔记如有侵权，请联系删除，谢谢！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>左耳朵耗子</tag>
      
      <tag>陈皓</tag>
      
      <tag>极客时间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向优秀-左耳朵耗子（陈皓）</title>
    <link href="/posts/b8d3ebe5.html"/>
    <url>/posts/b8d3ebe5.html</url>
    
    <content type="html"><![CDATA[<h2 id="向优秀的人学习"><a href="#向优秀的人学习" class="headerlink" title="向优秀的人学习"></a>向优秀的人学习</h2><p>从朋友圈了解到极客时间“左耳听风”专栏的活动。专栏里覆盖了陈皓 20 年的技术和管理经验以及学习总结，还有《程序员技术练级攻略》的重新阐述，这些经验都是学校或者工作中很难学到，作者不断学习、思考、总结所得的宝贵经验。看了陈皓的分享，我深深地震撼了，不管做技术还是管理，不管是工作还是生活，都可以尝试陈皓这种学习法则、对事情的态度、积极向上的心态。于是乎，我花了 69.9￥ 来学习陈皓的经验，希望能窥得一招半式，往后职业生涯中少走些弯路。</p><p>尤其是在自己迷茫的时候，更需要寻找一个目标，寻找一个自己想成为的那个人，然后制定计划，努力追赶。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200520-ChenHao-1.png" srcset="/img/loading.gif" alt=""></p><h2 id="邀请一起研读"><a href="#邀请一起研读" class="headerlink" title="邀请一起研读"></a>邀请一起研读</h2><p>陈皓专栏里随处都是非常高价值的经验总结，干货超级多，需要用心研读，也希望好的内容能跟大家一起学习。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20200524173130.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>人物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大佬</tag>
      
      <tag>左耳朵耗子</tag>
      
      <tag>陈皓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奋斗了四年的 NB-IOT 怎么让 Cat.1 成了最靓的仔？</title>
    <link href="/posts/54a9cdfe.html"/>
    <url>/posts/54a9cdfe.html</url>
    
    <content type="html"><![CDATA[<pre><code>奋斗了四年的 NB-IOT 怎么让 Cat.1 成了最靓的仔？NB-IOT 和 eMTC 怎么样了？</code></pre><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/WeChatGongZhongHao/2020/05/DaGang-1.png" srcset="/img/loading.gif" alt=""></p><h2 id="Cat-1-是什么"><a href="#Cat-1-是什么" class="headerlink" title="Cat.1 是什么"></a>Cat.1 是什么</h2><p>首先 Cat 是 Category 的缩写，中文意思是“类别，种类”，在 3GPP 中指 UE-Category（UE: User Equipment，用户设备）。</p><p>另外，Cat 后面的数字即代表不同的种类，3GPP 将不同种类的网络用 “Cat.X” 格式命名。根据 3GPP Release 定义，Cat.X 这个值是用来标识设备无线性能等级的，根据终端通讯速率来划分。</p><p>各种 “UE-Category” 和支持速率的对应关系见下表：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/WeChatGongZhongHao/2020/05/20200513225028.png" srcset="/img/loading.gif" alt=""></p><p>手机 4G 网络用的是哪个类别？</p><p>目前手机用的 4G 网络基本上才普及到 Cat.6，大多还停留在 Cat.4，这要看运营商和射频终端的支持情况。</p><p>划重点：</p><ul><li>Cat.X 是用来描述用户终端的能力等级</li><li>Cat.1 是 4G LTE 网络的一个类别，可以称为“低配版”的 4G 终端</li><li>Cat.1 属于蜂窝物联网，是广域网</li><li>Cat.1 通讯速率，上行 5.2Mbps，下行 10.3Mbps</li></ul><h2 id="Cat-1-为什么火了"><a href="#Cat-1-为什么火了" class="headerlink" title="Cat.1 为什么火了"></a>Cat.1 为什么火了</h2><p>NB-IOT 大张旗鼓推了这么多年，为什么 Cat1 成了最亮的仔？eMTC 又怎么样了？</p><p>这得从一张蜂窝物联网金字塔图开始说起：</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/WeChatGongZhongHao/2020/05/12aae1a59e99610a58f4909764f4c3b2.jpeg" srcset="/img/loading.gif" alt=""></p><p>在蜂窝物联网应用场景中，只有 10% 的高速业务需求，确有 60% 的超低速业务需求。在高速场景中，LTE Cat.4 以上级别的蜂窝模块可以满足需求；在超低速场景中，2G 蜂窝模块可以满足需求；在中低速场景中，有 2G/3G 蜂窝模块可以满足需求。</p><p>如上三种速率的应用场景都有对应的蜂窝模块满足要求，那为什么还需要 NB-IOT、Cat.1、eMTC 来支撑呢？主要有以下几个原因：</p><ul><li><p>2G/3G 退网的必然</p><p>  随着2G、3G的退网成为必然选择，基于4G/5G（NB-IoT+4G+5GNR）的物联网技术将担当起开启万物互联的大任。</p></li><li><p>5G 的建设，以及更好地利用频带</p><p>  手机等移动终端最终会迁移到 4G/5G 及以上网络，2G/3G 频带被闲置，4G 频带被 5G 分担，为了更好的利用频谱资源，那么需要将网络接入能力开发给有网络需求的众多物联网设备。</p></li><li><p>NB-IOT 无法满足中速率及移动特性需求</p></li><li><p>Cat.4 大材小用，成本高</p></li><li><p>政策</p><p>  近日，工信部办公厅发布了 <strong>《关于深入推进移动物联网全面发展的通知》</strong> （以下简称《通知》）也明确表示，<strong>以 NB-IoT 与 Cat.1 协同承接 2G/3G 物联连接，提升频谱利用效率</strong>。</p></li><li><p>物联网特性的需求</p><ul><li><p>小尺寸</p></li><li><p>超低功耗</p></li><li><p>成本敏感</p></li><li><p>所处网络环境差</p></li><li><p>广覆盖和超大规模接入需求</p><p>  百亿规模的物联网设备。</p></li></ul></li><li><p>Cat.1 优势</p><ul><li>无缝接入现有 3G/4G 网络</li><li>拥有跟 Cat.4 相同的毫秒级传输时延，以及支持 100KM/H 以上的移动速度。</li></ul></li></ul><p>由于物联网特性，3GPP 定义了 Cat.NB-1 级别的 NB-IOT 来承载超低速率应用场景的需求，主要是替代 2G 终端。另外，为了满足中低速物联网设备的网络需求，使用 3GPP 定义的 Cat.1 和 Cat.M1（eMTC）来替代 Cat.4 级别的 3G/4G 终端。</p><p>2G/3G 退网，已经建设多年的 NB-IOT 又无法满足中低速率场景的网络需求，而且 NB-IOT 又无法满足高速移动场景，所以 Cat.1 很快就火了起来，未来很有可能成为蜂窝物联网的主要通信制式。</p><h2 id="NB-IOT、eMTC-啥情况"><a href="#NB-IOT、eMTC-啥情况" class="headerlink" title="NB-IOT、eMTC 啥情况"></a>NB-IOT、eMTC 啥情况</h2><h3 id="NB-IOT-和-eMTC-在-3GPP-中的级别定义"><a href="#NB-IOT-和-eMTC-在-3GPP-中的级别定义" class="headerlink" title="NB-IOT 和 eMTC 在 3GPP 中的级别定义"></a>NB-IOT 和 eMTC 在 3GPP 中的级别定义</h3><p>3GPP 在 Release12/Release13 中增加了 Cat0、Cat.M1、Cat.NB-1 三个等级。</p><ul><li><p>Cat.0 放弃了对多天线的支持，简化为半双工，峰值速率降低为 1Mbit/s，终端复杂度降低为普通 LTE 终端的 40%，初步达到了物联网的成本要求；</p></li><li><p>Cat.M1 等级的终端信道带宽和射频接收带宽均为 1.4MHz，也就是我们常说的 eMTC（enhanced Machine-Type Communication，增强型机器类型通信）；</p></li><li><p>Cat.NB-1 接收带宽仅 180kHz，就是我们的 NB-IoT（Narrow Band Internet of Things，窄带物联网）。</p></li></ul><p>Cat.1、Cat.M1（eMTC）和 Cat.NB-1（NB-IoT）全都是用于蜂窝物联网的。其中，NB-IoT的速率最慢（200Kbps），eMTC 次之（1Mbps），Cat.1 最快（也就上行 5Mbps）。</p><p>划重点：</p><ul><li>NB-IOT 属于 Cat.NB-1 类别</li><li>eMTC 属于 Cat.M1 类别</li><li>速率：Cat.1 &gt; eMTC &gt; NB-IOT</li></ul><h3 id="为什么-eMTC-没有火"><a href="#为什么-eMTC-没有火" class="headerlink" title="为什么 eMTC 没有火"></a>为什么 eMTC 没有火</h3><p>从上文中可以看到 eMTC 和 Cat.1 共同承载中低速率的物联网设备网络需求，但 eMTC 为什么没有火？</p><p>上海域格信息技术有限公司市场总监朱凯分析说，eMTC 在国内的发展并不乐观，eMTC 需要基础设施建设，而运营商现在正将更多的资源投入到 5G 建设中，很难有多余的资金投入到 eMTC 建设中，另外国内应用案例有限，可借鉴度不高，开发难度大。</p><p>而近日工信部的《关于深入推进移动物联网全面发展的通知》也没有过多提到 eMTC，估计凉凉。</p><h3 id="NB-IOT-还香吗"><a href="#NB-IOT-还香吗" class="headerlink" title="NB-IOT 还香吗"></a>NB-IOT 还香吗</h3><p>目前市场上有两种声音：</p><ul><li>Cat.1 挤占 NB-IOT 市场，NB-IOT 应用场景狭窄，资费不能平衡网络运营成本，会淡出市场</li><li>NB-IOT 与 Cat.1 属于互补关系，且 NB-IOT 是未来 5G 非常重要的一个超大规模低速接入的切片</li></ul><p>当然，我更认可后者，NB-IOT 在 5G 中扮演着非常重要的角色。5G 三大场景中的海量机器通信（mMTC）、超高可靠低时延通信（uRLLC）均和物联网相关。其中 mMTC 将随着 NB-IoT 技术率先成熟，以及不涉及新空口技术等优势，会作为运营商 5G 优先发展的应用场景。</p><p>并且在近日工信部《关于深入推进移动物联网全面发展的通知》也 <strong>明确了建立 NB-IoT/4G(含 Cat.1)/5G 协同发展的移动物联网综合生态体系为总体目标，在深化 4G 网络覆盖、加快 5G 网络建设的基础上，以 NB-IoT 满足大部分低速率场景需求，以 Cat.1 满足中等速率物联需求和话音需求，以 5G 技术满足更高速率、低时延联网需求</strong>。</p><p>在工信部通知中明确提出 <strong>“推动 NB-IoT 标准纳入 ITU IMT-2020 5G 标准”</strong>，这无疑给 NB-IoT 技术产业吃了一颗定心丸。不用担心 NB-IoT 只是一个过渡性技术，做 NB-IoT 在 5G 时代将其长期存在。</p><p>此次工信部同时为 NB-IOT 和 Cat.1 站台做背书，足以表明 <strong>NB-IOT 依旧很香</strong>，Cat.1 前途大好。</p><p>NB-IOT 主要特点：</p><ul><li>广覆盖</li><li>超低功耗</li><li>低成本</li><li>大连接</li><li>低资费</li><li>支持基站定位</li><li>R14 支持 80KM/H 移动速度</li></ul><p>NBIOT 的主要应用场景：</p><ul><li>智能表计（水表、电表、燃气表）</li><li>智慧井盖</li><li>智慧烟感</li><li>智能环卫（智能垃圾桶）</li><li>智能门锁</li></ul><h2 id="Cat-1-现状"><a href="#Cat-1-现状" class="headerlink" title="Cat.1 现状"></a>Cat.1 现状</h2><p>随着紫光展锐、ASR 等芯片厂商发布性价比更高的 Cat.1 芯片之后，Cat.1 模组厂商扎堆发布了自家的模组，使得市场上的 Cat.1 模组价格已经迅速降至 45-60 元，玩家众多，竞争惨烈，基本重走 NB-IOT 的老路 —— 量未起，价已跌。</p><p>Cat.1 芯片原厂：</p><ul><li>高通 MDM9207-1(2016 年发布)</li><li>紫光展锐春藤 8910DM（28nm工艺，集成蓝牙和WiFi 室内定位）</li><li>翱捷 ASR3601</li><li><a href="https://altair-semi.com/products/alt1160/" target="_blank" rel="noopener">Sony Altair</a> ALT1160（2019 年发布）</li></ul><p>Cat.1 模组厂商（不完全统计）：</p><ul><li>中移物联网</li><li>移远通信</li><li>合宙电子</li><li>移柯通信</li><li>域格信息</li><li>广和通</li><li>芯讯通</li><li>高新兴物联</li><li>美格智能</li><li>有方科技</li><li>有人信息</li><li>信位通讯</li><li>锐骐(厦门)电子</li><li>深圳信可通讯</li><li>龙尚科技</li></ul><p>Cat.1 优势：</p><ul><li>相对 NB-IOT，其通信速率优势明显</li><li>相对 eMTC，其网络成本低</li><li>相对 Cat.4，其具有一定的成本优势</li></ul><p>Cat.1 劣势：</p><ul><li><p>现阶段芯片厂家少</p><p>  国外以高通为主，辅以 Sequans、Altair。</p><p>  国内主要是展锐和翱捷。</p></li><li><p>现阶段价格偏高</p><p>  NB-IoT、Cat.1、Cat.4 模组价格：</p><p>  <img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/WeChatGongZhongHao/2020/05/20200514113756.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>cat1 的主要市场和应用场景：</p><p>Cat.1 仍处于商用初期，落地的应用场景和案例还较少，一些明确的场景包括了共享、金融支付、工业控制、车载支付、公网对讲、POS 等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工信部办公厅发布了《关于深入推进移动物联网全面发展的通知》（以下简称《通知》）同时为 NB-IOT 和 Cat.1 站台，未来 NB-IOT 依旧很香，Cat.1 则前途大好。</p><p>随着新基建的启动，5G 打头，未来将是 NB-IOT、4G（包括 Cat.1）、5G 共同承载蜂窝物联网的连接，以应对不同层次的物联网业务需求。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.3gpp.org/DynaReport/36306.htm" target="_blank" rel="noopener">UE Category 速率</a></li><li><a href="https://www.3gpp.org/ftp/Information/WORK_PLAN/Description_Releases/" target="_blank" rel="noopener">3GPP Release</a></li><li><a href="https://mp.weixin.qq.com/s/4ej2iDrv-rsVYCN8qT0O8g" target="_blank" rel="noopener">物联传媒-12亿连接数、NB-IoT+Cat.1+5G深度覆盖，奔涌吧，物联网后浪！</a></li></ul><blockquote><p>本文基于互联网及微信公众号文章进行汇总总结，如有侵权请联系删除，谢谢。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NB-IOT</tag>
      
      <tag>物联网</tag>
      
      <tag>Cat.1</tag>
      
      <tag>eMTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 仓库侵权通知的思考</title>
    <link href="/posts/4101b91c.html"/>
    <url>/posts/4101b91c.html</url>
    
    <content type="html"><![CDATA[<h2 id="来自-GitHub-的侵权通知"><a href="#来自-GitHub-的侵权通知" class="headerlink" title="来自 GitHub 的侵权通知"></a>来自 GitHub 的侵权通知</h2><pre><code>[GitHub] DMCA Takedown NoticeMurphy May 12, 2020, 3:49:58 PM UTC Hi Murphy,I&#39;m contacting you on behalf of GitHub because we&#39;ve received a DMCA takedown notice regarding the following content:https://github.com/xxx/bookWe&#39;re giving you 1 business day to make the changes identified in the following notice:https://github.zendesk.com/attachments/token/xxx/?name=2020-05-12-packt.rtfIf you need to remove specific content from your repository, simply making the repository private or deleting it via a commit won&#39;t resolve the alleged infringement. Instead, you must follow these instructions to remove the content from your repository&#39;s history, even if you don&#39;t think it&#39;s sensitive:https://help.github.com/articles/remove-sensitive-dataOnce you&#39;ve made changes, please reply to this message and let us know. If you don&#39;t tell us that you&#39;ve made changes within the next 1 business day, we&#39;ll need to disable the entire repository according to our GitHub DMCA Takedown Policy:https://help.github.com/articles/dmca-takedown-policy/If you believe your content on GitHub was mistakenly disabled by a DMCA takedown request, you have the right to contest the takedown by submitting a counter notice, as described in our DMCA Takedown Policy.PLEASE NOTE: It is important that you reply to this message within 1 business day to tell us whether you&#39;ve made changes. If you do not, the repository will be disabled.</code></pre><p>以上是 GitHub DMCA 通知的全部内容，意思是我的 <code>book</code> 仓库中的部分书籍有侵权，需要我按照 github 指定的方式将侵权部分移除，否则我的 <code>book</code> 仓库会被 DMCA 禁用。</p><p>github 指定的删除方式参考 <a href="https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository" target="_blank" rel="noopener">https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository</a> 。使用该方式删除的目的是防止仓库提交记录中能够重新提取出侵权部分。该帮助文档提供了 <code>git filter-branch</code> 命令和 <code>BFG Repo-Cleaner</code> 开源工具两种方式来清理仓库中的敏感数据。</p><p>当然上面提到的方式都是高级用法，平时也基本用不到，如果你错误地将密码提交到了仓库中，那么则需要上面提到的方法。</p><p>本次我的 <code>book</code> 仓库是从上游 fork 过来的，考虑到我并不能排除仓库中电子书本身的版权问题，因此我选择完整移除整个仓库。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>互联网的发展给我们获取信息带来了非常大的效率提升，但也将版权问题推到了风口浪尖上，有效地进行版权保护需要互联网平台的努力，也需要每个互联网人的亲力亲为。</p><p>国内的版权问题也越来越受到重视，作为一个互联网人，我也更应该主动了解、关注、规避版权侵权问题。但是，这确实会给我的工作生活带来不便，因为字体、logo、图片等等基本上都有版权问题，如果每个人都需要了解如何规避版权，那势必给自己带来非常大的负担。因此，作为一个开源社区的一份子，我也希望能有更多的开源产品出现，以更好地服务这个社会。</p><p>开源的力量并不是无限的，希望大家尊重开源，支持开源，通过开源共享的方式，聚集众人智慧，提供更好的产品和服务。</p>]]></content>
    
    
    <categories>
      
      <category>开源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>版权</tag>
      
      <tag>GitHub</tag>
      
      <tag>DMCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的博客折腾记录</title>
    <link href="/posts/353d0a89.html"/>
    <url>/posts/353d0a89.html</url>
    
    <content type="html"><![CDATA[<h1 id="我的博客折腾记录"><a href="#我的博客折腾记录" class="headerlink" title="我的博客折腾记录"></a>我的博客折腾记录</h1><p>TODO</p><ul><li><p>国外线路走 github pages</p></li><li><p>国内线路走腾讯云对象存储 COS</p></li><li><p>图床使用腾讯云对象存储 COS 和 gitee</p></li><li><p>基于 github travis-ci 进行自动部署</p><p>  同时部署到 github pages 和腾讯云 COS。</p></li></ul><p>为什么一直坚持使用 github pages 和 gitee？</p><p>因为如果出于某种原因我不再维护自己的博客了，github pages 和 gitee 也还会持续提供稳定的服务，我提交的所有资源也不会消失，这就是我为什么使用 gitee 作为图床以及为什么所有的博客都托管到 github 的原因。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式操作系统</tag>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国产嵌入式操作系统发展思考</title>
    <link href="/posts/188732a5.html"/>
    <url>/posts/188732a5.html</url>
    
    <content type="html"><![CDATA[<h1 id="国产嵌入式操作系统发展思考"><a href="#国产嵌入式操作系统发展思考" class="headerlink" title="国产嵌入式操作系统发展思考"></a>国产嵌入式操作系统发展思考</h1><blockquote><p>偶然翻到了这篇老文章，出自何小庆（《嵌入式操作系统风云录：历史演进与物联网未来》作者），写的很好，汇总了当下国产 OS 的状态，遂分享出来。本文源自微博<a href="https://weibo.com/ttarticle/p/show?id=2309404428436692140206" target="_blank" rel="noopener">“麦克泰技术”</a>，<a href="https://mp.weixin.qq.com/s/gXWrPc0wqMqLzbViBPar2Q" target="_blank" rel="noopener">物联网学前班</a>公众号经授权转载分享。</p></blockquote><p>嵌入式操作系统历史悠久、门类繁多、用途广泛，不仅包括嵌入式实时多任务操作者系统（RTOS）、开源的 Linux、机器人和路由器操作系统，还包括新型的物联网操作系统，以及边缘计算操作系统平台。笔者认为，只要是国人开发的，国人参与维护的开源项目，都是广义上的“国产嵌入式操作系统”，随着中国物联网产业迅猛发展，国产装备自主可控需求旺盛，国产嵌入式操作系统发展步入快车道。</p><h2 id="国产物联网操作系统颇具影响力"><a href="#国产物联网操作系统颇具影响力" class="headerlink" title="国产物联网操作系统颇具影响力"></a>国产物联网操作系统颇具影响力</h2><p>睿赛德电子科技公司这个名字大家不是很熟悉，但是他们的产品 RT-Thread 在物联网和嵌入式开发者心目中是非常棒的开源软件，RT-Thread 是国内目前合作和支持芯片和厂商众多、社区开发者踊跃、组件丰富、应用领域广泛的国产物联网操作系统。2017 年以前，RT-Thread 还是一个传统的嵌入式操作系统，经过过去两年的发展，RT-Thread 在缩短产品开发周期、加快端云互联对接和提升设备端软件质量等方面做了大量工作，取得显著的成效。</p><p>华为 LiteOS 是另外一个在物联网领域颇具影响力的嵌入式操作系统。今天名气已经很大的华为可穿戴产品，比如 Huawei WatchGT，2015 年开始使用 LiteOS。超低功耗和超小的尺寸要求，给了 LiteOS 一个发展成熟的机会，到了 2017 年正式推出开源的物联网操作系统，LiteOS 已经初具规模很快在 NB-IoT 领域站稳了市场，特别是 OPEN CPU 的 NB-IOT 芯片和模组方案里面，都有 LiteOS 身影。在 HDC 2019 大会上，鸿蒙 OS 的当前的架构里面，LiteOS 也是其内核之一（Linux、鸿蒙和 LiteOS）。随着鸿蒙出现，未来 LiteOS 还是一个谜，但其针对 IoT 设备特有的素质，必将会融合进华为操作系统的布局里面。</p><h2 id="开源嵌入式操作系统助力创新发展"><a href="#开源嵌入式操作系统助力创新发展" class="headerlink" title="开源嵌入式操作系统助力创新发展"></a>开源嵌入式操作系统助力创新发展</h2><p>Zephyr 是 2016 年由 Intel、Synopsys、NXP 等公司发起的开源实时操作系统平台项目，现在由 Linux 基金会管理。项目旨在联合整个行业的领导者，构建针对资源小型受限设备，开发一个可扩展的嵌入式实时操作系统。Zephyr 虽然历史比较短，但起点很高，是发起公司和组织多年的经验教训的总结，最初的代码来自风河，风河的 vxwork RTOS 在工业和航空航天极有影响力。Zephyr 虽然只有 3 年的历史，相对 FreeRTOS 和 Contiki 等开源 RTOS，Zephyr 比较完备，中间件丰富。在安全设计方面 Zephyr 有缜密的考量，在代码规范中，Zephyr 用 MISRA C；在功能安全认证上，Zephyr 选择 IEC61508，这些功能开源嵌入式操作系统里面还没有其他项目能做到。Zephyr 有一个充满活力的国际开发社区，它和物联网操作系统中的 ARM Mbed OS、nuttX 和 RIOT 比较，活跃度很高。虽然 Zephyr 目前在中国关注度目前比较低，但技术上产品发展思路很值得国内同行的借鉴。</p><h2 id="自主可控、安全先行"><a href="#自主可控、安全先行" class="headerlink" title="自主可控、安全先行"></a>自主可控、安全先行</h2><p>国产嵌入式操作系统发展一个重要方向就是打造航空航天、工业装备和轨道交通、通信设备和汽车电子的自主可控的操作系统。面向装备与国防系统的嵌入式操作系统在可靠性、环境适应性、电磁兼容性、实时控制性方面都有自己的一套要求。华为在嵌入式操作系统方面的起步比较早，目前已经有基于开源的 Linux 自研的高可靠、高安全与高实时性的操作系统，覆盖了公司通信产品中的各个业务。华为的 RTOS 面向 5G 万物互联的物联网时代，对于操作系统安全方面的考虑尤其重视，可满足安全、可靠、自主的嵌入式实时操作系统要求。</p><p>上海华元创信研发的锐华高安全嵌入式操作系统（ReWorks Cert），符合功能安全标准 IEC 61508 SIL/SC3（通用）和EN 50128 SW SIL4（轨道交通），是国内目前少数通过国际第三方认证公司认证的嵌入式实时操作系统。目前ReWorks Cert 已率先成功应用于轨道交通信号领域龙头公司卡斯柯信号有限公司的安全计算机平台中，该计算机平台已成功通过 EN 50126 SIL4 等级认证。ReWorks Cert 有望在城市轨道交通领域获得规模化应用。</p><h2 id="技术发展、标准领航"><a href="#技术发展、标准领航" class="headerlink" title="技术发展、标准领航"></a>技术发展、标准领航</h2><p>嵌入式操作系统的发展离不开相关国家标准的制定，中国电子技术标准化研究院物联网中心正在着手物联网操作系统国家标准体系制订的前期研究工作。物联网操作系统的应用领域比较广泛，包括智慧城市、智能家居、交通运输、智能电网等场景，物联网操作系统标准的制定，工作需要产业和学术届的支持和帮助，为物联网的标准化建设贡献力量。物联网操作系统标准制定，对于物联网产业生态建设将更为重要，期待政府出台一些政策来促进物联网操作系统的健康良性发展等。</p><h2 id="嵌入式操作系统发展新趋势"><a href="#嵌入式操作系统发展新趋势" class="headerlink" title="嵌入式操作系统发展新趋势"></a>嵌入式操作系统发展新趋势</h2><p>物联网安全需要嵌入式操作系统通过安全认证，比如医疗电子 IEC 60601/62304、汽车电子 ISO 26262、航空电子 DO-178B/C 和核电 IEC 61513。老牌的嵌入式操作系统 QNX、Vxwork、Integrity 和 SafeRTOS 在安全认证起步比较早，Thread-X、uC/OS 和 embOS 这两年也迎头赶上，开源的 Zephery 正在做认证的工作，将要成为首家通过安全认证的开源嵌入式操作系统。上面讲到上海锐华的 RTOS 成功应用于轨道交通信号领域龙头公司卡斯柯信号有限公司的安全认证计算机平台中， 这说明国产嵌入式操作系统已经具备安全的能力并具备相应的技术能力。</p><p>嵌入式操作系统的虚拟化已经由来已久，几乎所有大的 RTOS 公司都有自己 Hypervisor 比如 ENEA 和风河，但是 Hypervisor 存在性能不高和缺少统一设备驱动的问题。随着容器技术在服务器和云计算成功采用，容器技术被证明具备应用级安全，这样轻量型容器技术受到物联网和嵌入式系统的关注。目前基于 Linux 轻量级容器技术研究进展比较大，比如 Canonical 推出的针对物联网以及边缘计算平台 Ubuntu Core 和它类似 Docker 的 Snap package 包管理软件，以及针对 IoT 的支持容器技术 ResinOS（现更名为 BalenaOS）。IoT 设备大量使用 MCU，无法运行 Linux，包括翼辉信息和华为等企业推出轻量级安全容器技术，即在它们 RTOS 基础上实现容器技术，已满足物联网时代安全、实时和快速布置和管理的新的需求。</p><p>嵌入式操作系统的内核继续呈现百花齐放局面，基于宏内核的 RTOS 仍占多数。微内核技术应用在商业 RTOS 的历史可以追溯到 90 年初，比如 VRTXsa，目前依然活跃在市场上代表性产品是 QNX，因为实时性等因素，微内核技术在代码受限的 MCU 上应用很少，比如 uc/OS、FreeRTOS 和 RT-Thread 都是宏内核技术。在 MCU 中如何能享受到大型 OS 的一些特性，同时保留 RTOS 在尺寸、实时性等方面的优势呢？AliOS Things 在 ARM 架构Cortex M 和 A 处理器上做了有益尝试，他们实现安全、多应用、内核可靠和动态低流量升级等技术特征。</p><p>AIOT 应用的对传统的操作系统提出新的课题，比如可扩展的内核技术、功能安全和信息安全、边缘计算架构的支持和应用 App 的便捷布置和管理。传统的移动操作系统比如 Android 和开源的 Linux 无法满足功能安全认证和强实时性的需要，传统的基于宏内核的 RTOS 无法满足系统扩展、维护和应用便捷的需要，针对 AIOT 场景的广义的嵌入式操作系统和泛 IoT OS 技术正在探索和研究中，比如无人驾驶汽车上的操作系统技术正在吸引产业和学术界关注。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>可以预见，嵌入式操作系统和 IoT OS 将向大型复杂和可配置、更小更安全和硬化两个方向发展，以适应物联网和人工智能时代，计算架构和应用软件平台发展的新需求。嵌入式软件经历了 80 年代微处理器和硬件设计占主导地位，软件在系统中比例很低；90 年代商业 RTOS 出现，解决了一部分软件复杂性问题；2000 年之后开源软件大规模采用，开发方法发生巨大的变革；2010 年之后 IoT 架构和应用驱动分布式实时软件回归；预计到了 2020 年“软件定义硬件”将驱动嵌入式软件开发方法变革，包括嵌入式和 IoT OS 的操作系统技术将迎来新的发展机遇。</p><blockquote><p>作者：何小庆，嵌入式系统知名专家、长期从事嵌入式与物联网技术、产业和教育方面工作，著有《嵌入式操作系统风云录：历史演进与物联网未来》等五本书籍和数十篇论文。</p></blockquote><p>总的来说，各个国产 RTOS 都已经在各自的领域内沉淀了多年，各有各的应用领域和生态，希望在物联网和人工智能时代能够看到他们的进一步的成长，不仅仅是在 MCU 领域，更是在高端 MPU 领域，不仅有国外芯片的支持，也有国内芯片平台的良好支持。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式操作系统</tag>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等保 2.0</title>
    <link href="/posts/f0cde271.html"/>
    <url>/posts/f0cde271.html</url>
    
    <content type="html"><![CDATA[<h1 id="等保-2-0"><a href="#等保-2-0" class="headerlink" title="等保 2.0"></a>等保 2.0</h1><p>这里的等保 2.0 是指网络安全等级保护制度 2.0 国家标准，该标准于 2019 年 05 月 10 日发布，并于 2019 年 12 月 01 日正式实施。那么到底什么是等级保护？等级保护 2.0 又有什么重大变化呢？</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>等保 2.0 标准名称为《信息安全技术 网络安全等级保护基本要求》，编号为 <code>GB/T 22239-2019</code>，基于等保 1.0 <code>GB/T 22239-2008</code> 进行修订。为了适配《中华人民共和国网络安全法》的实施，同时适应云计算、移动互联、物联网、工业控制和大数据等技术、新应用情况下的网络安全等级保护工作的开展，针对公共性安全保护需求提出安全通用要求，针对云计算、移动互联、物联网、工业控制和大数据等新技术、新应用领域的个性安全保护需求提出安全扩展要求，形成新的网络安全等级保护基本要求标准。</p><h2 id="等级保护对象"><a href="#等级保护对象" class="headerlink" title="等级保护对象"></a>等级保护对象</h2><p>等级保护对象是指网络安全等级保护工作中的对象，通常是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统，主要包括基础信息网络、云计算平台/系统、大数据应用/平台/资源、物联网（IoT）、工业控制系统和采用移动互联技术的系统等。等级保护对象根据其在国家安全、经济建设、社会生活中的重要程度，遭到破坏后对国家安全、社会秩序、公共利益以及公民、法人和其他组织的合法权益的危害程度等，由低到高被划分为五个安全保护等级。</p><p>五个安全保护等级由低到高分别为：</p><ul><li>安全通用要求</li><li>云计算安全扩展要求</li><li>移动互联安全扩展要求</li><li>物联网安全扩展要求</li><li>工业控制系统安全扩展要求</li></ul><h2 id="等保-2-0-的变化"><a href="#等保-2-0-的变化" class="headerlink" title="等保 2.0 的变化"></a>等保 2.0 的变化</h2><p>与 <code>GB/T 22239-2008</code> 相比，<code>GB/T 22239-2019</code> 的主要变化如下：</p><ul><li>变更标准名称为《信息安全技术 网络安全等级保护基本要求》；</li><li>调整分类为安全物理环境、安全通信网络、安全区域边界、安全计算环境、安全管理中心、安全管理制度、安全管理机构、安全管理人员、安全建设管理、安全运维管理；</li><li>调整各个级别的安全要求为安全通用要求、云计算安全扩展要求、移动互联网安全扩展要求、物联网安全扩展要求和工业控制系统安全扩展要求。</li></ul><h2 id="物联网安全扩展要求"><a href="#物联网安全扩展要求" class="headerlink" title="物联网安全扩展要求"></a>物联网安全扩展要求</h2><p>由于本人从事物联网行业相关工作，因此将 <code>GB/T 22239-2019</code> 标准中的物联网安全扩展要求摘录下来，以作参考。</p><h3 id="安全物理环境"><a href="#安全物理环境" class="headerlink" title="安全物理环境"></a>安全物理环境</h3><h4 id="感知节点设备物理防护"><a href="#感知节点设备物理防护" class="headerlink" title="感知节点设备物理防护"></a>感知节点设备物理防护</h4><p>本项要求包括：</p><p>a) 感知节点设备所处的物理环境不对感知节点设备造成物理破坏，如挤压、强振动；</p><p>b) 感知节点设备在工作状态所处物理环境应能正确反映环境状态（如温湿度传感器不能安装在阳光直射区域）；</p><p>c) 感知节点设备在工作状态所处物理环境应不对感知节点设备的正常工作造成影响，如强干扰、阻挡屏蔽等；</p><p>d) 关键感知节点设备应具有可供长时间工作的电力供应（关键网关节点设备应具有持久稳定的电力供应能力）。</p><h3 id="安全区域边界"><a href="#安全区域边界" class="headerlink" title="安全区域边界"></a>安全区域边界</h3><h4 id="接入控制"><a href="#接入控制" class="headerlink" title="接入控制"></a>接入控制</h4><p>应保证只有授权的感知节点可以接入。</p><h4 id="入侵防范"><a href="#入侵防范" class="headerlink" title="入侵防范"></a>入侵防范</h4><p>本项要求包括：</p><p>a) 应能够限制与感知节点通信的目标地址，以避免对陌生地址的攻击行为；</p><p>b) 应能够限制与网关节点通信的目标地址，以避免对陌生地址的攻击行为。</p><h3 id="安全计算环境"><a href="#安全计算环境" class="headerlink" title="安全计算环境"></a>安全计算环境</h3><h4 id="感知节点设备安全"><a href="#感知节点设备安全" class="headerlink" title="感知节点设备安全"></a>感知节点设备安全</h4><p>本项要求包括：</p><p>a) 应保证只有授权的用户可以对感知节点设备上的软件应用进行配置或变更；</p><p>b) 应具有对其连接的网关节点设备（包括读卡器）进行身份标识和鉴别的能力；</p><p>c) 应具有对其连接的其他感知节点设备（包括路由节点）进行身份标识和鉴别的能力。</p><h4 id="网关节点设备安全"><a href="#网关节点设备安全" class="headerlink" title="网关节点设备安全"></a>网关节点设备安全</h4><p>本项要求包括：</p><p>a) 应具备对合法连接设备（包括终端节点、路由节点、数据处理中心）进行标识和鉴别的能力；</p><p>b) 应具备过滤非法节点和伪造节点所发送的数据的能力；</p><p>c) 授权用户应能够在设备使用过程中对关键密钥进行在线更新；</p><p>d) 授权用户应能够在设备使用过程中对关键配置参数进行在线更新。</p><h4 id="抗数据重放"><a href="#抗数据重放" class="headerlink" title="抗数据重放"></a>抗数据重放</h4><p>本项要求包括：</p><p>a) 应能够鉴别数据的新鲜性，避免历史数据的重放攻击；</p><p>b) 应能够鉴别历史数据的非法修改，避免数据的修改重放攻击。</p><h4 id="数据融合处理"><a href="#数据融合处理" class="headerlink" title="数据融合处理"></a>数据融合处理</h4><p>本项要求包括：</p><p>a) 应对来自传感网的数据进行数据融合处理，使不同种类的数据可以在同一个平台被使用；</p><p>b) 应对不同数据之间的依赖关系和制约关系等进行智能处理，如一类数据达到某个门限时可以影响对另一类数据采集终端的管理指令。</p><h3 id="安全运维管理"><a href="#安全运维管理" class="headerlink" title="安全运维管理"></a>安全运维管理</h3><h4 id="感知节点管理"><a href="#感知节点管理" class="headerlink" title="感知节点管理"></a>感知节点管理</h4><p>本项要求包括：</p><p>a) 应指定人员定期巡视感知节点设备、网关节点设备的部署环境，对可能影响感知节点设备、网关节点设备正常工作的环境异常进行记录和维护；</p><p>b) 应对感知节点设备、网关节点设备入库、存储、部署、携带、维修、丢失和报废等过程作出明确规定，并进行全程管理；</p><p>c) 应加强对感知节点设备、网关节点设备部署环境的保密性管理，包括负责检查和维护的人员调离工作岗位应立即交还相关检查工具和检查维护记录等。</p><h2 id="物联网应用场景说明"><a href="#物联网应用场景说明" class="headerlink" title="物联网应用场景说明"></a>物联网应用场景说明</h2><p>物联网通常从架构上可分为三个逻辑层，即感知层、网络传输层和处理应用层。其中感知层包括传感器节点和传感网网关节点，或 RFID 标签和 RFID 读卡器，也包括这些感知设备及传感网网关、RFID 标签与阅读器之间的短距离通信（通常为无线）部分；网络传输层包括将这些感知数据远距离传输到处理中心的网络，包括互联网、移动网等，以及几种不同网络的融合；处理应用层报对感知数据进行存储于智能处理的平台，并对业务应用终端提供服务。对大型物联网来说，处理应用层一般是云计算平台和业务应用终端设备。物联网构成示意图如图 F.1 所示。对物联网的安全防护应包括感知层、网络传输层和处理应用层，由于网络传输层和处理应用层通常是由计算机设备构成，因此这两部分按照安全通用要求提出的要求进行保护，本标准的物联网安全扩展要求针对感知层提出特殊安全要求，与安全通用要求一起构成对物联网的完整安全要求。</p><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/GBT22239-2019WuliangwangGoucheng.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="等级保护安全框架"><a href="#等级保护安全框架" class="headerlink" title="等级保护安全框架"></a>等级保护安全框架</h2><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/GBT22239-2019DengjibaohuAnquanKuangjia.png" srcset="/img/loading.gif" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>等保 2.0 将信息安全和网络安全划分为五个安全等级，涉及到基础信息网络、云计算平台/系统、大数据应用/平台/资源、物联网（IoT）、工业控制系统和采用移动互联技术的系统等，全方位指导企业确保网络信息安全。配合《中华人民共和国网络安全法》，企业有责任和义务确保本企业内所有产品网络信息安全。企业可以基于 <code>GB/T 22239-2019</code> 及其附属文档，根据相关检测标准进行自查，并最终通过相关相关测评要求（参考 <code>GB/T 28448</code> 标准）。</p><p>在信息大爆炸，物联网大爆发的时代，网络安全问题不容小觑，2016 年的物联网僵尸网络攻击以及 2019 年的小米摄像头视频泄露等问题，已经为我们敲响了安全警钟，未来安全之路任重道远，与每个人息息相关。等保 2.0 系列安全安全标准已经给出了基本的安全框架，未来定能更好地指导企业做好基础的网络信息安全。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=BAFB47E8874764186BDB7865E8344DAF" target="_blank" rel="noopener">GB/T 22239-2019</a></li><li><a href="http://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=D13C8CD02AFC374BC31048590EB75445" target="_blank" rel="noopener">GB/T 22239-2008</a></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>以上内容摘自 <code>GB/T 22239-2019</code> 标准文档，部分内容纯属个人理解，仅供学习参考，如有侵权，请联系删除。如果以上内容与 <code>GB/T 22239-2019</code> 有冲突，请以 <code>GB/T 22239-2019</code> 中的原文为主。</p><blockquote><p>本文禁止转载。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>安全标准</category>
      
    </categories>
    
    
    <tags>
      
      <tag>等保 2.0</tag>
      
      <tag>GB/T 22239-2019</tag>
      
      <tag>安全标准</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他与其它的区别</title>
    <link href="/posts/7daccdaf.html"/>
    <url>/posts/7daccdaf.html</url>
    
    <content type="html"><![CDATA[<h2 id="其他与其它的区别"><a href="#其他与其它的区别" class="headerlink" title="其他与其它的区别"></a>其他与其它的区别</h2><p>区别在于：在写文章时，不论指人还是指事物，用 “其他” 都是对的；而 “其它” 则只在指事物时才能用。</p><p>规范的说 “其他” 用的对象是人，而 “其它” 用的对象是除人以外的任何东西（比如植物，动物，微生物，事物等） 最初只有 “其他” 这个词，“他” 意思是 “另外的”。</p><hr><blockquote><p>以上内容来源网络，侵删。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
      <tag>其它</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 #、##、__VA_ARGS__、#__VA_ARGS__、##__VA_ARGS__</title>
    <link href="/posts/40137057.html"/>
    <url>/posts/40137057.html</url>
    
    <content type="html"><![CDATA[<pre><code>‘#’ 和 ‘##’ 属于预处理标记。‘#’ 和 ‘##’ 用于类似函数的宏定义中（或者简称为宏定义函数）。‘__VA_ARGS__’ 是 C99 引入的用于支持宏定义函数中使用可变参数。</code></pre><h2 id="操作符-‘-’"><a href="#操作符-‘-’" class="headerlink" title="操作符 ‘#’"></a>操作符 ‘#’</h2><p>在宏定义展开的时候，标记 ‘#’ 用于将 ‘#’ 后面的宏定义函数中的参数转化为对应的字符串。宏定义函数的参数与预处理标记 ‘#’ 之间出现的每一个空格都会被删除，并删除第一个预处理标记之前和最后一个预处理标记之后的空白字符，但是宏定义函数参数中的空格会保留。</p><p>其中，空参数转化为为空，即宏定义函数入参为空，那么展开的时候也为空。</p><p>上面的这段话比较难理解，这里为了准确地传达其意义，我们来看一个示例程序。</p><blockquote><p>在看到代码后，可以先猜猜可能的输出结果，如果你答对了，那就是真的会了！<br>注意，这里我基于 RT-Thread QEMU BSP 进行代码展示，代码真实编译通过，运行正常。</p></blockquote><h3 id="示例程序-A"><a href="#示例程序-A" class="headerlink" title="示例程序 A"></a>示例程序 A</h3><p>请看以下代码：</p><pre><code>#include &lt;stdint.h&gt;#include &lt;rtthread.h&gt;#define mkstr(var) (#var)int main(void){    rt_kprintf(&quot;hello rt-thread\n&quot;);    rt_kprintf(mkstr(hello rt-thread));    return 0;}</code></pre><p>请问：</p><ul><li>它能编译通过吗？</li><li>它能输出什么内容？</li></ul><p>答案：</p><ul><li><p>它可以正常编译通过</p></li><li><p>它输出的内容</p><pre><code>  hello rt-thread  hello rt-threadmsh /&gt;</code></pre></li></ul><p>从上面输出的信息可以看到，<code>hello rt-thread</code> 字符串被准确地输出到了控制台，但是没有增加回车换行。其中 <code>msh /&gt;</code> 字符串是 RT-Thread 控制台回显。</p><p>如上，代码 <code>rt_kprintf(mkstr(hello rt-thread));</code> 中的 <code>hello rt-thread</code> 在没有加引号的情况下，被转化成了字符串。</p><h3 id="示例程序-B"><a href="#示例程序-B" class="headerlink" title="示例程序 B"></a>示例程序 B</h3><p>为示例程序 A 打印的字符串增加回车换行。</p><pre><code>#include &lt;stdint.h&gt;#include &lt;rtthread.h&gt;#define mkstr(var) (#var)int main(void){    rt_kprintf(&quot;hello rt-thread\n&quot;);    rt_kprintf(mkstr(hello rt-thread\r\n));    return 0;}</code></pre><p>有了示例 A 的基础，示例 B 那就是 soeasy，直接在原有的基础上增加 <code>\r\n</code> 转义字符即可输出回车换行。</p><p>输出结果如下：</p><pre><code>hello rt-threadhello rt-threadmsh /&gt;</code></pre><h3 id="示例程序-C"><a href="#示例程序-C" class="headerlink" title="示例程序 C"></a>示例程序 C</h3><p>我们在示例程序 B 中成功增加了回车换行的输出，但是你有没有想过一个问题，如果你又很多地方用到 <code>mkstr</code> 宏定义函数输出信息，那你是不是每一个地方都要增加 <code>\r\n</code>，这岂不是很累，有没有好的方法？</p><p>好方法当然有，下面介绍下程序中常用的方式，利用 C 语言相邻字符串自动拼接的特性（当然，这是编译器支持的）。代码如下：</p><pre><code>#include &lt;stdint.h&gt;#include &lt;rtthread.h&gt;#define mkstr(var) (#var&quot;\r\n&quot;)int main(void){    rt_kprintf(&quot;hello rt-thread\n&quot;);    rt_kprintf(mkstr(hello rt-thread));    return 0;}</code></pre><p>以上代码在 <code>#var</code> 后面增加了一个字符串 <code>\r\n</code>，我们来看宏定义展开过程：</p><pre><code>-&gt; rt_kprintf(mkstr(hello rt-thread));-&gt; rt_kprintf(&quot;hello rt-thread&quot;&quot;\r\n&quot;);-&gt; rt_kprintf(&quot;hello rt-thread\r\n&quot;);</code></pre><h3 id="示例程序-D"><a href="#示例程序-D" class="headerlink" title="示例程序 D"></a>示例程序 D</h3><p>预处理标记 <code>#</code> 的基本用法已经展示完了，但怎么理解 “宏定义函数的参数与预处理标记 ‘#’ 之间出现的每一个空格都会被删除，并删除第一个预处理标记之前和最后一个预处理标记之后的空白字符”？</p><p>请看下面的代码：</p><pre><code>#include &lt;stdint.h&gt;#include &lt;rtthread.h&gt;#define mkstr(var) (&quot;aa&quot;  #  var  &quot;bb&quot;)int main(void){    rt_kprintf(&quot;hello rt-thread\n&quot;);    rt_kprintf(mkstr(hello rt-thread));    return 0;}</code></pre><p>宏定义 <code>mkstr(var) (&quot;aa&quot;  #  var  &quot;bb\r\n&quot;)</code> 中的 <code>#  var</code> 中间有两个空格，根据定义，<code>#</code> 号与宏定义函数参数 <code>var</code> 中间的两个空格会被删除，但是 <code>var</code> 参数中的 <code>hello rt-thread</code> 中的空格不会被删除。</p><p>继续，根据定义，宏定义 <code>mkstr(var) (&quot;aa&quot;  #  var  &quot;bb\r\n&quot;)</code> 中只有一个预处理标记 <code>#</code>，其作为第一个和最后一个预处理标记，它前面和后面的空格都会被删除。</p><p>因此，以上代码预计输出结果为:</p><pre><code>hello rt-threadaahello rt-threadbbmsh /&gt;</code></pre><h3 id="示例程序-E"><a href="#示例程序-E" class="headerlink" title="示例程序 E"></a>示例程序 E</h3><p>在实际操作时，操作符 <code>#</code> 被常用于枚举转字符串。以下代码截取自我的 <a href="https://github.com/murphyzhao/FlexibleButton/blob/master/flexible_button_demo.c" target="_blank" rel="noopener">FlexibleButton 按键库</a> 的示例程序。</p><pre><code>#define ENUM_TO_STR(e) (#e)typedef enum{    USER_BUTTON_0 = 0,    USER_BUTTON_1,    USER_BUTTON_2,    USER_BUTTON_3,    USER_BUTTON_MAX} user_button_t;static char *enum_btn_id_string[] = {    ENUM_TO_STR(USER_BUTTON_0),    ENUM_TO_STR(USER_BUTTON_1),    ENUM_TO_STR(USER_BUTTON_2),    ENUM_TO_STR(USER_BUTTON_3),    ENUM_TO_STR(USER_BUTTON_MAX),};</code></pre><h2 id="操作符-‘-’-1"><a href="#操作符-‘-’-1" class="headerlink" title="操作符 ‘##’"></a>操作符 ‘##’</h2><p>‘##’ 是预处理拼接标记。在宏定义展开的时候，将 ‘##’ 左边的内容，与 ‘##’ 右边的内容拼接到一起。</p><p>注意，对于任何一种形式的宏定义，‘##’ 预处理标记都不应出现在<em>替换列表</em>的开头或结尾。</p><p>关于<em>替换列表</em>：</p><p>例如宏定义 ‘#define aa(x, y) (x##y)’ 后面的部分 ‘x##y’ 就是替换列表。</p><p>预处理拼接符 <code>##</code> 常用于使用宏定义批量生成函数或者变量。</p><h3 id="示例程序-F"><a href="#示例程序-F" class="headerlink" title="示例程序 F"></a>示例程序 F</h3><pre><code>#include &lt;stdint.h&gt;#include &lt;rtthread.h&gt;#define my_math(x, y) (x##e##y)int main(void){    rt_kprintf(&quot;hello rt-thread\n&quot;);    printf(&quot;%e\r\n&quot;, my_math(3, 4));    return 0;}</code></pre><p>以上代码是科学计数法的格式输出到控制台，输出内容如下：</p><pre><code>hello rt-thread3.000000e+04msh /&gt;</code></pre><h3 id="示例程序-G"><a href="#示例程序-G" class="headerlink" title="示例程序 G"></a>示例程序 G</h3><p>用预处理拼接符 <code>##</code> 批量生成函数或者变量。</p><p>以下代码截取自 <a href="https://github.com/RT-Thread/rt-thread/blob/master/components/finsh/finsh_api.h" target="_blank" rel="noopener">RT-Thread <code>finsh_api.h</code></a>，该段代码用于导出 Finsh 命令，代码如下所示：</p><pre><code>#define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      \    const char __fsym_##cmd##_name[] SECTION(&quot;.rodata.name&quot;) = #cmd;    \    const char __fsym_##cmd##_desc[] SECTION(&quot;.rodata.name&quot;) = #desc;   \    RT_USED const struct finsh_syscall __fsym_##cmd SECTION(&quot;FSymTab&quot;)= \    {                           \        __fsym_##cmd##_name,    \        __fsym_##cmd##_desc,    \        (syscall_func)&amp;name     \    };</code></pre><p>该宏定义的应用，如 <code>list_timer</code> 命令，如下所示：</p><pre><code>FINSH_FUNCTION_EXPORT_CMD(list_timer, list_timer, list timer in system);</code></pre><h2 id="标识符-VA-ARGS"><a href="#标识符-VA-ARGS" class="headerlink" title="标识符 __VA_ARGS__"></a>标识符 <code>__VA_ARGS__</code></h2><p><code>__VA_ARGS__</code> 是在 C99 中增加的新特性。虽然 C89 引入了一种标准机制，允许定义具有可变数量参数的函数，但是 C89 中不允许这种定义可变数量参数的方式出现在宏定义中。C99 中加入了 <code>__VA_ARGS__</code> 关键字，用于支持在宏定义中定义可变数量参数，用于接收 <code>...</code> 传递的多个参数。<a href="#refer-anchor-1"><sup>1</sup></a></p><p><code>__VA_ARGS__</code> 只能出现在使用了省略号的像函数一样的宏定义里。例如 <code>#define myprintf(...) fprintf(stderr, __VA_ARGS__)</code>。</p><h3 id="解析不定参"><a href="#解析不定参" class="headerlink" title="解析不定参"></a>解析不定参</h3><p>通过宏定义，将多个参数传递给函数，那么函数是如何解析不定参的呢？</p><p>这就需要使用标准库头文件 <code>&lt;stdarg.h&gt;</code> 中的三个宏，分别是 “va_start()”、“va_arg()”、“va_end()”，以及一个可变参类型 “va_list”，示例使用方式借用 RT-Thread 中的 <code>rt_sprintf</code> 的实现，代码如下所示：</p><pre><code>rt_int32_t rt_sprintf(char *buf, const char *format, ...){    rt_int32_t n;    va_list arg_ptr;    va_start(arg_ptr, format);    n = rt_vsprintf(buf, format, arg_ptr);    va_end(arg_ptr);    return n;}</code></pre><ul><li>首先使用 “va_list” 类型定义一个变量 “arg_ptr”</li><li>然后调用 “va_start(arg_ptr, format);” 函数，第一个入参是 “va_list” 类型，第二个参数是 “rt_sprintf” 函数参数列表中的最后一个定参 “format”</li><li>然后，通过调用 “rt_vsprintf” 函数，根据 “format” 来解析不定参，并将结果存放到 “buf” 中</li><li>最后，使用 “va_end(arg_ptr);” 来释放不定参列表占用的资源</li></ul><h2 id="带-‘-’-的标识符-VA-ARGS"><a href="#带-‘-’-的标识符-VA-ARGS" class="headerlink" title="带 ‘#’ 的标识符 #__VA_ARGS__"></a>带 ‘#’ 的标识符 <code>#__VA_ARGS__</code></h2><p>预处理标记 ‘#’ 用于将宏定义参数转化为字符串，因此 <code>#__VA_ARGS__</code> 会被展开为参数列表对应的字符串。</p><p>示例：</p><pre><code>#define showlist(...) put(#__VA_ARGS__)测试如下：showlist(The first, second, and third items.);showlist(arg1, arg2, arg3);输出结果分别为：The first, second, and third items.arg1, arg2, arg3</code></pre><h2 id="带-‘-’-的标识符-VA-ARGS-1"><a href="#带-‘-’-的标识符-VA-ARGS-1" class="headerlink" title="带 ‘##’ 的标识符 ##__VA_ARGS__"></a>带 ‘##’ 的标识符 <code>##__VA_ARGS__</code></h2><p><code>##__VA_ARGS__</code> 是 GNU 特性，不是 C99 标准的一部分，C 标准不建议这样使用，但目前已经被大部分编译器支持。</p><p>标识符 <code>##__VA_ARGS__</code> 的意义来自 ‘##’，主要为了解决一下应用场景：</p><pre><code>#define myprintf_a(fmt, ...) printf(fmt, __VA_ARGS__)#define myprintf_b(fmt, ...) printf(fmt, ##__VA_ARGS__)应用：myprintf_a(&quot;hello&quot;);myprintf_b(&quot;hello&quot;);myprintf_a(&quot;hello: %s&quot;, &quot;world&quot;);myprintf_b(&quot;hello: %s&quot;, &quot;world&quot;);</code></pre><p>这个时候，编译器会报错，如下所示：</p><pre><code>applications\main.c: In function &#39;main&#39;:applications\main.c:26:57: error: expected expression before &#39;)&#39; token #define myprintf_a(fmt, ...) printf(fmt, __VA_ARGS__)                                                         ^applications\main.c:36:5: note: in expansion of macro &#39;myprintf_a&#39;     myprintf_a(&quot;hello&quot;);</code></pre><p>为什么呢？</p><p>我们展开 <code>myprintf_a(&quot;hello&quot;);</code> 之后为 <code>printf(&quot;hello&quot;,)</code>。因为没有不定参，所以，<code>__VA_ARGS__</code> 展开为空白字符，这个时候，printf 函数中就多了一个 ‘,’（逗号），导致编译报错。而 <code>##__VA_ARGS__</code> 在展开的时候，因为 ‘##’ 找不到连接对象，会将 ‘##’ 之前的空白字符和 ‘,’（逗号）删除，这个时候 printf 函数就没有了多余的 ‘,’（逗号）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div id="refer-anchor-1"></div><ul><li><p>[1] <a href="http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899" target="_blank" rel="noopener">open-std 网站</a></p><ul><li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/C99RationaleV5.10.pdf" target="_blank" rel="noopener">C99 标准 V5.10</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" target="_blank" rel="noopener">C99 公共版本 N1256</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" target="_blank" rel="noopener">C11 公共版本 N1570</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>__VA_ARGS__</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 添加文献引用</title>
    <link href="/posts/49cc9dcc.html"/>
    <url>/posts/49cc9dcc.html</url>
    
    <content type="html"><![CDATA[<h2 id="增加引用的文献列表"><a href="#增加引用的文献列表" class="headerlink" title="增加引用的文献列表"></a>增加引用的文献列表</h2><p>示例如下：</p><pre><code>## 参考- [1] [百度学术](http://xueshu.baidu.com/)- [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)</code></pre><h2 id="增加锚点"><a href="#增加锚点" class="headerlink" title="增加锚点"></a>增加锚点</h2><pre><code>## 参考&lt;div id=&quot;refer-anchor-1&quot;&gt;&lt;/div&gt;- [1] [百度学术](http://xueshu.baidu.com/)&lt;div id=&quot;refer-anchor-2&quot;&gt;&lt;/div&gt;- [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)</code></pre><h2 id="增加引用"><a href="#增加引用" class="headerlink" title="增加引用"></a>增加引用</h2><p>使用 <code>&lt;sup&gt;</code> 标注引用，如下所示：</p><pre><code>## Markdown 增加文献引用这边文章是介绍如何在 Markdown 中增加文献引用。[&lt;sup&gt;1&lt;/sup&gt;](#refer-anchor-1)## 参考&lt;div id=&quot;refer-anchor-1&quot;&gt;&lt;/div&gt;- [1] [百度学术](http://xueshu.baidu.com/)&lt;div id=&quot;refer-anchor-2&quot;&gt;&lt;/div&gt;- [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="Markdown-增加文献引用"><a href="#Markdown-增加文献引用" class="headerlink" title="Markdown 增加文献引用"></a>Markdown 增加文献引用</h3><p>这边文章是介绍如何在 Markdown 中增加文献引用。<a href="#refer-anchor-1"><sup>1</sup></a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div id="refer-anchor-1"></div><ul><li>[1] <a href="http://xueshu.baidu.com/" target="_blank" rel="noopener">百度学术</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2] <a href="https://en.wikipedia.org/wiki/Main_Page" target="_blank" rel="noopener">Wikipedia</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>文献引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/4a17b156.html"/>
    <url>/posts/4a17b156.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread TCP/UDP 客户端程序</title>
    <link href="/posts/ec31c22a.html"/>
    <url>/posts/ec31c22a.html</url>
    
    <content type="html"><![CDATA[<p>最近发现不止一个人再要基于 RT-Thread 的 TCP 和 UDP 示例代码，包括 SAL 方式的。</p><p>这里给出一个我自己写的示例程序吧，希望可以帮到需要的人。</p><p>代码一键下载地址，<a href="https://download.csdn.net/download/u012349679/11970969" target="_blank" rel="noopener">点我</a>。</p><h2 id="TCP-客户端"><a href="#TCP-客户端" class="headerlink" title="TCP 客户端"></a>TCP 客户端</h2><pre><code>/* * Copyright (c) 2006-2019, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date           Author            Notes * 2019-07-09     MurphyZhao        first version */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;rtthread.h&gt;#ifdef RT_USING_SAL#include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt;#include &quot;sal_tls.h&quot;#include &quot;sys/time.h&quot;#else#include &quot;lwip/sockets.h&quot;#include &quot;lwip/netdb.h&quot;#include &quot;lwip/sys.h&quot;#include &quot;lwip/inet.h&quot;#endif /* RT_USING_SAL */#define LOG_TAG              &quot;demo.tcp&quot;#define LOG_LVL              LOG_LVL_DBG#include &lt;ulog.h&gt;#define TCP_TEST_HOST    &quot;www.rt-thread.com&quot;#define TCP_TEST_PORT    (80u)#define TEST_BUFSZ       (1024u)static const char *req_data = &quot;GET /service/rt-thread.txt HTTP/1.1\r\n&quot;    &quot;Host: www.rt-thread.com\r\n&quot;    &quot;User-Agent: rtthread/4.0.1 rtt\r\n\r\n&quot;;static char req_uri[128];static int  req_port;static void nb_tcp_demo(int argc, char** argv){    int ret;    int sock = -1;    struct hostent *host;    struct sockaddr_in server_addr;    int bytes_received;    char *recv_data;    char ip_addr_buf[64];    if ((argc != 1) &amp;&amp; (argc != 3))    {        LOG_E(&quot;In param error&quot;);        LOG_I(&quot;cmd: demo_tcp [&lt;host&gt; &lt;port&gt;]&quot;);        LOG_I(&quot;eg:  demo_tcp&quot;);        LOG_I(&quot;     demo_tcp 127.0.0.1 8080&quot;);        return;    }    rt_memset(req_uri, 0x0, sizeof(req_uri));    if (argc == 3)    {        rt_strncpy(req_uri, argv[1], rt_strlen(argv[1]));        req_port = atoi(argv[2]);    }    else    {        rt_strncpy(req_uri, TCP_TEST_HOST, rt_strlen(TCP_TEST_HOST));        req_port = TCP_TEST_PORT;    }    LOG_I(&quot;TCP demo start&quot;);    LOG_I(&quot;Host:%s; Port:%d&quot;, req_uri, req_port);    LOG_D(&quot;will gethostbyname...&quot;);    host = gethostbyname(req_uri);    if (!host)    {        LOG_E(&quot;gethostbyname failed!&quot;);        return;    }    LOG_I(&quot;gethostbyname pass. ip addr: %s&quot;, inet_ntoa_r(*((struct in_addr *)host-&gt;h_addr_list[0]), ip_addr_buf, sizeof(ip_addr_buf)));    recv_data = rt_calloc(1, TEST_BUFSZ);    if (recv_data == RT_NULL)    {        LOG_E(&quot;calloc failed. No memory!&quot;);        return;    }    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)    {        LOG_E(&quot;Create socket failed!&quot;);        goto __exit;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(req_port);    server_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);    rt_memset(&amp;(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));    if ((ret = connect(sock, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr))) &lt; 0)    {        LOG_E(&quot;Connect &lt;%d&gt; fail! ret:%d&quot;, sock, ret);        goto __exit;    }    LOG_I(&quot;connect &lt;%s&gt; success&quot;, ip_addr_buf);    ret = send(sock, req_data, strlen(req_data), 0);    if (ret &lt;= 0)    {        LOG_E(&quot;send error, will close the socket &lt;%d&gt;.&quot;, sock);        goto __exit;    }    LOG_I(&quot;send success&quot;);    bytes_received = recv(sock, recv_data, TEST_BUFSZ  - 1, 0);    if (bytes_received &lt;= 0)    {        LOG_E(&quot;receive error, will close the socket &lt;%d&gt;.&quot;, sock);        goto __exit;    }    LOG_I(&quot;received data:\n&quot;);    for (int i = 0; i &lt; bytes_received; i++)    {        rt_kprintf(&quot;%c&quot;, recv_data[i]);    }    rt_kprintf(&quot;\r\n&quot;);__exit:    if (recv_data)        rt_free(recv_data);    if (sock &gt;= 0)    {        closesocket(sock);        sock = -1;    }    LOG_I(&quot;TCP demo end&quot;);}#ifdef FINSH_USING_MSH#include &lt;finsh.h&gt;MSH_CMD_EXPORT_ALIAS(nb_tcp_demo, demo_tcp, nbiot tcp test);#endif /* FINSH_USING_MSH */</code></pre><h2 id="UDP-客户端"><a href="#UDP-客户端" class="headerlink" title="UDP 客户端"></a>UDP 客户端</h2><pre><code>/* * Copyright (c) 2006-2019, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date           Author            Notes * 2019-07-09     MurphyZhao        first version */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;rtthread.h&gt;#ifdef RT_USING_SAL#include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt;#include &quot;sal_tls.h&quot;#include &quot;sys/time.h&quot;#else#include &quot;lwip/sockets.h&quot;#include &quot;lwip/netdb.h&quot;#include &quot;lwip/sys.h&quot;#include &quot;lwip/inet.h&quot;#endif /* RT_USING_SAL */#define LOG_TAG              &quot;demo.udp&quot;#define LOG_LVL              LOG_LVL_DBG#include &lt;ulog.h&gt;#define TCP_TEST_HOST    &quot;114.116.144.151&quot;#define TCP_TEST_PORT    (2010u)#define TEST_BUFSZ       (1024u)static const char *req_data = &quot;This message is from NB-IOT UDP Client with RT-Thread.\n&quot;;static char req_uri[128];static int  req_port;static void nb_udp_demo(int argc, char** argv){    int ret;    int sock = -1;    struct hostent *host;    struct sockaddr_in server_addr;    char *recv_data;    int bytes_received;    char ip_addr_buf[64];    LOG_I(&quot;UDP demo start&quot;);    if ((argc != 1) &amp;&amp; (argc != 3))    {        LOG_E(&quot;In param error&quot;);        LOG_I(&quot;cmd: demo_udp [&lt;host&gt; &lt;port&gt;]&quot;);        LOG_I(&quot;eg:  demo_udp&quot;);        LOG_I(&quot;     demo_udp 127.0.0.1 8080&quot;);        return;    }    rt_memset(req_uri, 0x0, sizeof(req_uri));    if (argc == 3)    {        rt_strncpy(req_uri, argv[1], rt_strlen(argv[1]));        req_port = atoi(argv[2]);    }    else    {        rt_strncpy(req_uri, TCP_TEST_HOST, rt_strlen(TCP_TEST_HOST));        req_port = TCP_TEST_PORT;    }    LOG_I(&quot;Host:%s; Port:%d&quot;, req_uri, req_port);    LOG_D(&quot;will gethostbyname...&quot;);    host = gethostbyname(req_uri);    if (!host)    {        LOG_E(&quot;gethostbyname failed!&quot;);        return;    }    LOG_I(&quot;gethostbyname pass. ip addr: %s&quot;, inet_ntoa_r(*((struct in_addr *)host-&gt;h_addr_list[0]), ip_addr_buf, sizeof(ip_addr_buf)));    recv_data = rt_calloc(1, TEST_BUFSZ);    if (recv_data == RT_NULL)    {        LOG_E(&quot;calloc failed. No memory!&quot;);        return;    }    if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)    {        LOG_E(&quot;Create socket failed!&quot;);        goto __exit;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(req_port);    server_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);    rt_memset(&amp;(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));    if ((ret = connect(sock, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr))) &lt; 0)    {        LOG_E(&quot;Connect &lt;%d&gt; fail! ret:%d&quot;, sock, ret);        goto __exit;    }    LOG_I(&quot;connect &lt;%s&gt; success&quot;, ip_addr_buf);    ret = send(sock, req_data, strlen(req_data), 0);    if (ret &lt;= 0)    {        LOG_E(&quot;send error, will close the socket &lt;%d&gt;.&quot;, sock);        goto __exit;    }    LOG_I(&quot;send success&quot;);    bytes_received = recv(sock, recv_data, TEST_BUFSZ - 1, 0);    if (bytes_received &lt;= 0)    {        LOG_E(&quot;receive error, will close the socket &lt;%d&gt;.&quot;, sock);        goto __exit;    }    LOG_I(&quot;received data:\n&quot;);    for (int i = 0; i &lt; bytes_received; i++)    {        rt_kprintf(&quot;%c&quot;, recv_data[i]);    }    rt_kprintf(&quot;\r\n&quot;);__exit:    if (recv_data)        rt_free(recv_data);    if (sock &gt;= 0)    {        closesocket(sock);        sock = -1;    }    LOG_I(&quot;UDP demo end&quot;);}#ifdef FINSH_USING_MSH#include &lt;finsh.h&gt;MSH_CMD_EXPORT_ALIAS(nb_udp_demo, demo_udp, nbiot udp test);#endif /* FINSH_USING_MSH */</code></pre>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>TCP Client</tag>
      
      <tag>TCP 客户端</tag>
      
      <tag>UDP 客户端</tag>
      
      <tag>UDP Client</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 上安装 iperf</title>
    <link href="/posts/47feda29.html"/>
    <url>/posts/47feda29.html</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-上安装-iperf"><a href="#Ubuntu-上安装-iperf" class="headerlink" title="Ubuntu 上安装 iperf"></a>Ubuntu 上安装 iperf</h1><blockquote><p>最近 NB-IOT 项目需要进行外网测试，那么就先用 iperf 测个速度吧。</p><p>网速不一定能够反映真实情况，跟您使用的外网服务器带宽也有关系。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre><code>git clone https://github.com/esnet/iperf.git</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>依次执行以下命令：</p><pre><code>$ cd iperf$ ./configure$ sudo ldconfig /usr/local/lib$ make$ make install</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li><p>运行 server</p><p>  <code>iperf3 -s</code></p></li><li><p>运行 client</p><p>  <code>iperf3 -c server_addr -p server_port</code></p></li></ul><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><pre><code>$ sudo nohup iperf3 -s &gt;&gt; iperf_s.log 2&gt;&amp;1 &amp;</code></pre><p>注意 iperf3 后台运行需要使用 root 权限，否则终端退出后，服务也就结束了。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="无法找到-libiperf-soxx"><a href="#无法找到-libiperf-soxx" class="headerlink" title="无法找到 libiperf.soxx"></a>无法找到 libiperf.soxx</h3><p>在运行 <code>iperf3 -s</code> 的时候，提示以下错误：</p><pre><code>iperf3: error while loading shared libraries: libiperf.so.0: cannot open shared object file: No such file or directory</code></pre><p>简单的解决方法，在 iperf Git 仓库根目录执行以下命令：</p><pre><code>sudo ldconfig /usr/local/lib</code></pre><p>参考 <a href="https://github.com/esnet/iperf/issues/153" target="_blank" rel="noopener">github issue</a>。</p><h3 id="不能解析客户端参数"><a href="#不能解析客户端参数" class="headerlink" title="不能解析客户端参数"></a>不能解析客户端参数</h3><pre><code>iperf3: error - unable to receive parameters from client:</code></pre><p>该问题是因为使用了不同版本的客户端服务器软件导致的。因为 iperf3 与 iperf2 不兼容。<br>解决方法是使用相同版本的客户端和服务器。</p><p>参考 <a href="https://github.com/esnet/iperf/issues/153" target="_blank" rel="noopener">github issue</a>。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iperf</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离线 API 文档查看工具</title>
    <link href="/posts/5f8936a3.html"/>
    <url>/posts/5f8936a3.html</url>
    
    <content type="html"><![CDATA[<p>写代码，API 用法记不住，那就需要一个程序员词典，推荐下两个好用的离线 API 查看工具，程序员的百科全书。</p><ul><li><a href="https://kapeli.com/dash" target="_blank" rel="noopener">DASH</a></li></ul><p>仅可以用于 apple 产品，IOS 系统下。</p><ul><li><a href="https://zealdocs.org/" target="_blank" rel="noopener">zeal</a></li></ul><p>zeal 就很良心了，Windows 下可用，文档也不比 DASH 少，界面干净，下载速度也比较快。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DASH</tag>
      
      <tag>zeal</tag>
      
      <tag>程序员词典</tag>
      
      <tag>API 文档查看工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NB-IOT 模块 MT2625 使用总结</title>
    <link href="/posts/25fa1dd2.html"/>
    <url>/posts/25fa1dd2.html</url>
    
    <content type="html"><![CDATA[<h1 id="MT2625-NB-IOT-SOC-应用"><a href="#MT2625-NB-IOT-SOC-应用" class="headerlink" title="MT2625 NB-IOT SOC 应用"></a>MT2625 NB-IOT SOC 应用</h1><blockquote><p>基于中移物联网 M5311 模块。</p></blockquote><h2 id="AT-建立-UDP-连接"><a href="#AT-建立-UDP-连接" class="headerlink" title="AT 建立 UDP 连接"></a>AT 建立 UDP 连接</h2><blockquote><p>查询 apn：AT+CGDCONT?</p></blockquote><ol><li><p>激活 apn</p><p> AT+EGACT=1,1,”cmnbiot6”,””,””</p><p> 其中 cmnbiot6 为查询到的 apn</p></li><li><p>建立 socket</p><p> AT+ESOC=1,2,1</p></li><li><p>建立连接</p><p> AT+ESOCON=0,PORT,”IPADDR”</p><p> AT+ESOCON=0,2039,”114.116.144.151” “118.31.15.152”</p></li><li><p>发送数据</p><p> AT+ESOSEND=0,2,3132</p></li><li><p>断开连接</p><p> AT+ESODIS=0</p></li><li><p>关闭 socket</p><p> AT+ESOCL=0  </p></li></ol><h2 id="AT-建立-TCP-连接"><a href="#AT-建立-TCP-连接" class="headerlink" title="AT 建立 TCP 连接"></a>AT 建立 TCP 连接</h2><ol><li><p>激活 apn</p><p> AT+EGACT=1,1,”cmnbiot6”,””,””</p></li><li><p>建立 socket</p><p> AT+ESOC=1,1,1</p></li><li><p>建立连接</p><p> AT+ESOCON=0,PORT,”IPADDR”</p><p> AT+ESOCON=0,2039,”114.116.144.151”</p></li><li><p>发送数据</p><p> AT+ESOSEND=0,2,3132</p></li><li><p>断开连接</p><p> AT+ESODIS=0</p></li><li><p>关闭 socket</p><p> AT+ESOCL=0</p></li></ol><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><pre><code>AT+EDNS=&quot;baidu.com&quot;</code></pre><h2 id="AT-接入-OneNET"><a href="#AT-接入-OneNET" class="headerlink" title="AT 接入 OneNET"></a>AT 接入 OneNET</h2><h3 id="AT-MIPLCREATE"><a href="#AT-MIPLCREATE" class="headerlink" title="AT+MIPLCREATE"></a>AT+MIPLCREATE</h3><p>AT+MIPLCREATE=<totalsize>,<config>,<index>,<currentsize>,<flag></p><ul><li><totalsize><p>  该参数表示参数 <config> 字符串的长度，ASCII 码数量。</p></li><li><config></li></ul><p>官方资料上的示例：</p><pre><code>AT+MIPLCREATE=56,130038F10003F2002A04001100000000000010196E62696F7462742E6865636C6F7564732E636F6D3A35363833000131F30008F100000000,0,56,0</code></pre><p>该指令可以不加参数，以使用默认参数，可以按照如下方式使用默认参数：</p><p>发送：</p><pre><code>AT+MIPLCREATE</code></pre><p>接收：</p><pre><code>+MIPLCREATE: 0OK</code></pre><h3 id="OneNET-接入完整示例"><a href="#OneNET-接入完整示例" class="headerlink" title="OneNET 接入完整示例"></a>OneNET 接入完整示例</h3><pre><code>AT+CGPADDR=1+CGPADDR: 1,&quot;100.81.104.244&quot;OKAT+MIPLCREATE+MIPLCREATE: 0OKAT+MIPLADDOBJ=0,3303,1,1,1,0AT+MIPLOPEN=0,86400    +MIPLOBSERVE:0,76658,1,3303,0,-1AT+MIPLOBSERVERSP=0,76658,1    +MIPLDISCOVER=0,11123,1,3200AT+MIPLDISCOVERRSP=0,11123,1,4,&quot;5700&quot;AT+MIPLNOTIFY=0,76658,3303,0,5700,4,4,102.00,0,0</code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="1-获取-IMEI（国际移动设备识别码，即移动设备序列号）"><a href="#1-获取-IMEI（国际移动设备识别码，即移动设备序列号）" class="headerlink" title="1. 获取 IMEI（国际移动设备识别码，即移动设备序列号）"></a>1. 获取 IMEI（国际移动设备识别码，即移动设备序列号）</h3><pre><code>AT+GSN</code></pre><h3 id="2-获取-IMSI（国际移动用户识别码，SIM-卡标识）"><a href="#2-获取-IMSI（国际移动用户识别码，SIM-卡标识）" class="headerlink" title="2. 获取 IMSI（国际移动用户识别码，SIM 卡标识）"></a>2. 获取 IMSI（国际移动用户识别码，SIM 卡标识）</h3><pre><code>AT+CIMI</code></pre><h3 id="3-查信号质量"><a href="#3-查信号质量" class="headerlink" title="3. 查信号质量"></a>3. 查信号质量</h3><pre><code>AT+CSQ</code></pre><h3 id="4-查-ip-地址"><a href="#4-查-ip-地址" class="headerlink" title="4. 查 ip 地址"></a>4. 查 ip 地址</h3><h3 id="5-查-apn"><a href="#5-查-apn" class="headerlink" title="5. 查 apn"></a>5. 查 apn</h3><pre><code>AT+CGDCONT?</code></pre><h3 id="6-激活-apn"><a href="#6-激活-apn" class="headerlink" title="6. 激活 apn"></a>6. 激活 apn</h3><p>AT+EGACT=1,1,”cmnbiot6”,””,””</p><h3 id="7-查射频开关"><a href="#7-查射频开关" class="headerlink" title="7. 查射频开关"></a>7. 查射频开关</h3><p>AT+CFUN?</p><h3 id="8-查网络注册状态"><a href="#8-查网络注册状态" class="headerlink" title="8. 查网络注册状态"></a>8. 查网络注册状态</h3><p>AT+CEREG?</p><h3 id="9-DNS"><a href="#9-DNS" class="headerlink" title="9. DNS"></a>9. DNS</h3><p>AT+EDNS=”baidu.com”</p><h3 id="10-查-CGSN"><a href="#10-查-CGSN" class="headerlink" title="10. 查 CGSN"></a>10. 查 CGSN</h3><p>AT+CGSN</p><h3 id="11-低功耗相关"><a href="#11-低功耗相关" class="headerlink" title="11. 低功耗相关"></a>11. 低功耗相关</h3><ul><li><p>AT+SM=D_STA 查询深度睡眠模式状态</p></li><li><p>AT+SM=H_L 关闭轻度睡眠模式</p></li><li><p>AT+SM=H_U 打开轻度睡眠模式</p></li><li><p>AT+SM=H_DS_L 关闭深度睡眠模式</p></li><li><p>AT+SM=H_DS_U 打开深度睡眠模式</p></li><li><p>AT+SM=UNLOCK_FOREVER 开启自动睡眠，重启后保持开启状态</p></li><li><p>AT+SM=LOCK_FOREVER 关闭自动睡眠，重启后保持关闭状态</p></li></ul><h3 id="12-查询和控制串口"><a href="#12-查询和控制串口" class="headerlink" title="12. 查询和控制串口"></a>12. 查询和控制串口</h3><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20190924100507763.png" srcset="/img/loading.gif" alt=""></p><ul><li>AT+EPORT=0 显示串口分配情况</li></ul><pre><code>AT+EPORT=0+EPORT: uls = 2+EPORT: connl = 0+EPORT: emmi = 1OK</code></pre><ul><li>AT+EPORT=4 显示存储在 NVDM 中的串口配置</li></ul><pre><code>AT+EPORT=4+EPORT: 0baudrate = 9+EPORT: 1baudrate = 9+EPORT: 2baudrate = 9+EPORT: 3baudrate = 9+EPORT: 4none+EPORT: 5noneOK</code></pre><ul><li>uls: 对应 HSL</li><li>connl: 对应 AT 串口</li><li>emmi: 对应 GKI 串口</li></ul><h4 id="切换端口"><a href="#切换端口" class="headerlink" title="切换端口"></a>切换端口</h4><pre><code>AT+EPORT=1,connl,1</code></pre><h4 id="切换波特率"><a href="#切换波特率" class="headerlink" title="切换波特率"></a>切换波特率</h4><ul><li>切换到 921600：AT+EPORT=3,0,12</li><li>切换到 115200：AT+EPORT=3,0,9</li></ul><p>第一个参数是命令，第二个参数是串口号，第三个参数是波特率标识。波特率编号根据程序里的枚举值确定，如下：</p><pre><code>typedef enum {    HAL_UART_BAUDRATE_110 = 0,           /**&lt; Defines UART baudrate as 110 bps. */    HAL_UART_BAUDRATE_300 = 1,           /**&lt; Defines UART baudrate as 300 bps. */    HAL_UART_BAUDRATE_1200 = 2,          /**&lt; Defines UART baudrate as 1200 bps. */    HAL_UART_BAUDRATE_2400 = 3,          /**&lt; Defines UART baudrate as 2400 bps. */    HAL_UART_BAUDRATE_4800 = 4,          /**&lt; Defines UART baudrate as 4800 bps. */    HAL_UART_BAUDRATE_9600 = 5,          /**&lt; Defines UART baudrate as 9600 bps. */    HAL_UART_BAUDRATE_19200 = 6,         /**&lt; Defines UART baudrate as 19200 bps. */    HAL_UART_BAUDRATE_38400 = 7,         /**&lt; Defines UART baudrate as 38400 bps. */    HAL_UART_BAUDRATE_57600 = 8,         /**&lt; Defines UART baudrate as 57600 bps. */    HAL_UART_BAUDRATE_115200 = 9,        /**&lt; Defines UART baudrate as 115200 bps. */    HAL_UART_BAUDRATE_230400 = 10,       /**&lt; Defines UART baudrate as 230400 bps. */    HAL_UART_BAUDRATE_460800 = 11,       /**&lt; Defines UART baudrate as 460800 bps. */    HAL_UART_BAUDRATE_921600 = 12,       /**&lt; Defines UART baudrate as 921600 bps. */#ifdef HAL_UART_FEATURE_3M_BAUDRATE    HAL_UART_BAUDRATE_3000000 = 13,      /**&lt; Defines UART baudrate as 3000000 bps. */    HAL_UART_BAUDRATE_1500000 = 14,      /**&lt; Defines UART baudrate as 1500000 bps. */#endif    HAL_UART_BAUDRATE_MAX                /**&lt; Defines maximum enum value of UART baudrate. */} hal_uart_baudrate_t;</code></pre><h3 id="13-UEs-power-save-mode-PSM"><a href="#13-UEs-power-save-mode-PSM" class="headerlink" title="13. UEs power save mode (PSM)"></a>13. UEs power save mode (PSM)</h3><ul><li>AT+CPSMS：控制 UE 是否进入 PSM 模式，并获取 E-UTRAN 中请求的周期性 TAU 和网络分配给 UE 的活动时间。</li></ul><p>命令的特殊形式可以是 <code>+ CPSMS = 2</code>。 在此形式中，将禁用 PSM 的使用，并且将删除命令 <code>+ CPSMS</code> 中所有参数的数据，或者，如果可用，将其设置为制造商特定的默认值。</p><p>test 命令返回支持的 <mode> 以及 E-UTRAN 中请求的扩展周期性 TAU 值的值范围和请求的活动时间值作为复合值。</p><p>测试命令：</p><p>返回值说明：</p><pre><code>+CPSMS: (list of supported &lt;mode&gt;s),(list of supported &lt;Requested_Periodic-RAU&gt;s),(listof supported &lt;Requested_GPRS-READY-timer&gt;s),(list of supported &lt;Requested_PeriodicTAU&gt;s),(list of supported &lt;Requested_Active-Time&gt;s)</code></pre><pre><code>AT+CPSMS=?+CPSMS: (0-2),,,(&quot;00000000&quot;-&quot;1101111&quot;),(&quot;00000000&quot;-&quot;11111111&quot;)OK</code></pre><p>读命令：</p><p>返回值说明：</p><pre><code>+CPSMS:&lt;mode&gt;,[&lt;Requested_Periodic-RAU&gt;],[&lt;Requested_GPRS-READYtimer&gt;],[&lt;Requested_Periodic-TAU&gt;],[&lt;Requested_Active-Time&gt;]</code></pre><p>示例：</p><pre><code>AT+CPSMS?+CPSMS: 1,,,&quot;00100011&quot;,&quot;00100010&quot;OK</code></pre><p>执行命令：</p><h3 id="14-PING"><a href="#14-PING" class="headerlink" title="14. PING"></a>14. PING</h3><pre><code>AT+PING=&lt;ip&gt;</code></pre><p>只能 PING ipv4 地址，不能 PING 域名和 ipv6 地址。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NB-IOT</tag>
      
      <tag>MT2625</tag>
      
      <tag>M5311</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言内存 dump 函数</title>
    <link href="/posts/de9ea2d9.html"/>
    <url>/posts/de9ea2d9.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码片段。</p><p>在调试的时候经常要打印内存里的数据，来看看数据及格式是否在预期范围内；以及在调试二进制协议的时候，经常需要将协议包里的数据打印出来，这个时候就会涉及到 HEX 数据的展示问题。</p><p>这篇文章就是展示如何优雅地打印 HEX 数据。</p><p>按照 BeyondCompare 形式打印 HEX 数据。</p></blockquote><p><img src="https://gitee.com/zhaojuntao/PictureBed/raw/master/blog/ArticleImage/20201127225326.png" srcset="/img/loading.gif" alt=""></p><hr><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>代码如下：</p><pre><code class="C">#define __is_print(ch) ((unsigned int)((ch) - &#39; &#39;) &lt; 127u - &#39; &#39;)void dump_hex(const uint8_t *buf, uint32_t size){    int i, j;    for (i = 0; i &lt; size; i += 16)    {        printf(&quot;%08X: &quot;, i);        for (j = 0; j &lt; 16; j++)        {            if (i + j &lt; size)            {                printf(&quot;%02X &quot;, buf[i + j]);            }            else            {                printf(&quot;   &quot;);            }        }        printf(&quot; &quot;);        for (j = 0; j &lt; 16; j++)        {            if (i + j &lt; size)            {                printf(&quot;%c&quot;, __is_print(buf[i + j]) ? buf[i + j] : &#39;.&#39;);            }        }        printf(&quot;\n&quot;);    }}</code></pre><p>测试代码：</p><pre><code>int main(void){    uint8_t i, buff[128];    for (i = 0; i &lt; sizeof(buff); i++)    {        buff[i] = i;    }    dump_hex((const uint8_t *)buff, sizeof(buff), 16);    return 0;}</code></pre><p>测试效果：</p><pre><code>00000000: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  ................00000010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F  ................00000020: 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F   !&quot;#$%&amp;&#39;()*+,-./00000030: 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F  0123456789:;&lt;=&gt;?00000040: 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO00000050: 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~.</code></pre><h2 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h2><p>相对基础版本，每行每 8 个数据多增加一个空格，数据展示更加直观。</p><pre><code class="C">#define __is_print(ch) ((unsigned int)((ch) - &#39; &#39;) &lt; 127u - &#39; &#39;)/** * dump_hex *  * @brief dump data in hex format *  * @param buf: User buffer * @param size: Dump data size * @param number: The number of outputs per line *  * @return void*/void dump_hex(const uint8_t *buf, uint32_t size, uint32_t number){    int i, j;    for (i = 0; i &lt; size; i += number)    {        printf(&quot;%08X: &quot;, i);        for (j = 0; j &lt; number; j++)        {            if (j % 8 == 0)            {                printf(&quot; &quot;);            }            if (i + j &lt; size)                printf(&quot;%02X &quot;, buf[i + j]);            else                printf(&quot;   &quot;);        }        printf(&quot; &quot;);        for (j = 0; j &lt; number; j++)        {            if (i + j &lt; size)            {                printf(&quot;%c&quot;, __is_print(buf[i + j]) ? buf[i + j] : &#39;.&#39;);            }        }        printf(&quot;\n&quot;);    }}</code></pre><p>测试结果：</p><pre><code>00000000:  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  ................00000010:  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  ................00000020:  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !&quot;#$%&amp;&#39;()*+,-./00000030:  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;&lt;=&gt;?00000040:  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO00000050:  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_00000060:  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno00000070:  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~.</code></pre>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存数据打印</tag>
      
      <tag>内存 dump</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM GCC 库打桩——符号替换</title>
    <link href="/posts/c09a7f69.html"/>
    <url>/posts/c09a7f69.html</url>
    
    <content type="html"><![CDATA[<p>开发中，难免会遇到只有库没有源码的情况，调试的时候，库里的几个函数又非常关键，那我们怎么控制里面的流程呢，并插入自己代码？</p><p>这个时候就需要使用 GCC 工具重定义库中的符号，然后在外面包装该函数。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>一个库：lib_test.a</p><p>库中的函数：void hello_test_lib(void);</p><p>现在，我们想把库里面的 <code>hello_test_lib</code> 函数替换为 <code>new_hello_test_lib</code>，需要以下步骤：</p><ul><li>复制一份 lib_test.a 为 lib_test_bak.a</li></ul><pre><code>arm-none-eabi-objcopy lib_test.a lib_test_bak.a</code></pre><ul><li>重定义符号</li></ul><pre><code>arm-none-eabi-objcopy --redefine-sym hello_test_lib=new_hello_test_lib lib_test.a lib_test_bak.a</code></pre><ul><li>重命名 <code>lib_test_bak.a</code> 为 <code>lib_test.a</code> 即可</li></ul><h2 id="重定义符号前后的应用差别"><a href="#重定义符号前后的应用差别" class="headerlink" title="重定义符号前后的应用差别"></a>重定义符号前后的应用差别</h2><p>重定义符号，其实就是把库里原来的函数名换成新的函数名，所以在函数调用关系上就多了一层。</p><p>上面的例子中，原来的调用关系假设如下：</p><pre><code>void main(void){    hello_test_lib();}</code></pre><p>那么，重定义符号后，函数调用关系编程了如下所示：</p><pre><code>void hello_test_lib(void){    new_hello_test_lib();}void main(void){    hello_test_lib();}</code></pre><p>在 main 函数中调用了库里的函数 <code>hello_test_lib</code>，但是库里的函数已经被我们重定义为了 <code>new_hello_test_lib</code>    ，所以，调用关系上，需要我们在外部实现一个被替换的原来的函数接口 <code>hello_test_lib</code>。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCC 库打桩</tag>
      
      <tag>GCC 符号替换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单个文件编译优化配置</title>
    <link href="/posts/67f2f08.html"/>
    <url>/posts/67f2f08.html</url>
    
    <content type="html"><![CDATA[<p>单独设置一个 C 文件的优化级别，支持 MDK、IAR、GCC，代码如下：</p><pre><code>#if defined(__CC_ARM)    #pragma O1#elif defined(__ICCARM__)    #pragma optimize=none#elif defined(__GNUC__)    #pragma GCC optimize (&quot;O0&quot;)#endif</code></pre>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 遍历删除指定格式文件</title>
    <link href="/posts/3c8114a9.html"/>
    <url>/posts/3c8114a9.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码放在自己电脑上总是找不到，那就放到博客里吧。</p></blockquote><p>在做嵌入式开发的时候，总是会生成很多中间文件（如 <code>.o</code> 文件），所有有时候需要去查找删除这样的文件，所以就写了这个一个 python 脚本。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>假定你将该代码命名为 <code>rm_specifial_file.py</code>。</p><pre><code class="python">#!/user/bin/python#coding:utf-8import sys, osimport time# 解决乱码问题reload(sys)sys.setdefaultencoding(&quot;utf-8&quot;)def recursive_del_files(del_path, del_file_format, is_delete = False):    del_file_list = []    for root , dirs, files in os.walk(del_path):        for name in files:            for file_format in del_file_format:                if name.endswith(file_format):                    now = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)                    if is_delete:                        os.remove(os.path.join(root, name))                    del_file = os.path.join(root, name)                    del_file = &quot;[ &quot; + now + &quot; ]&quot; + &quot; [ DELETE ]  &quot; + del_file                    del_file_list.append(del_file)    return del_file_listdef recursive_del_file_write(filename, del_file_list):    fopen = open(filename, &#39;a&#39;)    for temp in del_file_list:        fopen.write(temp+&#39;\n&#39;)    fopen.close()if __name__ == &#39;__main__&#39;:    print(&quot;==== In main function of (%s) ====&quot; % (__file__))    print(sys.argv)    is_delete = False    if (len(sys.argv) == 2):        if (sys.argv[1] == &#39;-d&#39;):            is_delete = True    removed_file_list = recursive_del_files(os.getcwd(), [&#39;.o&#39;], is_delete)    recursive_del_file_write(&#39;removed_file.txt&#39;, removed_file_list)</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>假定你将上述代码命名为 <code>rm_specifial_file.py</code>。</p><h3 id="只查看，不删除"><a href="#只查看，不删除" class="headerlink" title="只查看，不删除"></a>只查看，不删除</h3><pre><code>python rm_specifial_file.py</code></pre><p>运行后，查到的所有文件存储在当前目录下的 <code>removed_file.txt</code> 文件中。</p><h3 id="遍历删除"><a href="#遍历删除" class="headerlink" title="遍历删除"></a>遍历删除</h3><pre><code>python rm_specifial_file.py -d</code></pre><p>使用 <code>-d</code> 参数来使能遍历删除。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python 遍历删除</tag>
      
      <tag>删除指定文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread DHT11 温湿度传感器驱动</title>
    <link href="/posts/e9be041d.html"/>
    <url>/posts/e9be041d.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>分享一个我整理的 <a href="https://github.com/murphyzhao/dht11_rtt" target="_blank" rel="noopener">DHT11 温湿度传感器驱动 dht11_rtt 软件包</a></p></blockquote><p><a href="https://github.com/murphyzhao/dht11_rtt" target="_blank" rel="noopener">dht11_rtt</a> 是基于 RT-Thread 物联网操作系统实现的 dht11 驱动软件包，该软件包托管在 GitHub，使用 <code>Apache-2.0</code> 协议许可。</p><p><a href="https://github.com/murphyzhao/dht11_rtt" target="_blank" rel="noopener">dht11_rtt</a> 驱动使用了 RT-Thread Sensor 传感器框架和 Pin 驱动框架，因此在使用的过程中需要开启这两个功能。不过，在使用 RT-Thread 的 menuconfig 进行配置的时候会默认选中 Sensor 和 Pin 设备配置。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DHT11 数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有枀高的可靠性与卓越的长期稳定性。传感器包括一个电阻式感湿元件和一个 NTC 测温元件，幵与一个高性能 8 位单片机相连接，对外提供单总线通讯接口。更多 DHT11 的使用说明请参考 DHT11 厂家数据手册。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://github.com/murphyzhao/dht11_rtt" target="_blank" rel="noopener">dht11_rtt</a> 驱动软件包提供了示例程序，menuconfig 配置如下：</p><p>选择一个 BSP 工程，使用 menuconfig 命令打开如下界面：</p><p><img src="https://img-blog.csdnimg.cn/2019081722242710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>由 menuconfig 配置保存后，使用 <code>pkgs --update</code> 命令将该软件包从 github 下载到本地 bsp 工程中。</p><p>该示例程序使用了 RT-Thread 的组件初始化特性，编译下载后，板卡上电的时候自动完成初始化工作，不需要用户修改任何代码（可能需要修改 DHT11 使用的 GPIO，示例中使用的是 GPIOB_12）。</p><p>修改 DHT11 连接的 GPIO 管脚：</p><p>在 <code>dht11_sample.c</code> 中修改以下代码：</p><pre><code>#define DHT11_DATA_PIN    GET_PIN(B, 12)</code></pre><p>程序编译下载到板卡后，会在串口中每 1s 打印一次温湿度数据。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>DHT11 是采用单总线通讯的传感器，本软件包采用 GPIO 模拟单总线时序。DHT11 的一次完整读时序需要 20ms，时间过长，故无法使用关中断或者关调度的方式实现独占 CPU 以保证时序完整正确。因此可能出现读取数据失败的情况，请用户注意。</p><p>DHT11 通讯时序：</p><pre><code>主机发送起始信号 —&gt; DHT11 检测到并发送响应信号DHT11 发送 40 位数据（HSB） —&gt; DHT11 发送结束信号</code></pre>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>DHT11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主流嵌入式操作系统（RTOS）有哪些？看看这14种</title>
    <link href="/posts/cb5d44c7.html"/>
    <url>/posts/cb5d44c7.html</url>
    
    <content type="html"><![CDATA[<p>看到 21ic 公众号发布了一篇文章 <a href="https://mp.weixin.qq.com/s/Ty9u3V6ksTgoujE8UsSDcA" target="_blank" rel="noopener">主流嵌入式操作系统（RTOS）有哪些？看看这14种</a>，收藏过来。</p><p>除了上面文章总结的 RTOS 之外，我发现了一个很好的 RTOS 汇总的网站 <a href="https://www.osrtos.com/，里面汇总了市面上流行的" target="_blank" rel="noopener">https://www.osrtos.com/，里面汇总了市面上流行的</a> RTOS，并给出了使用的开源协议、支持的平台、简单的描述、开源地址，非常有用的一个汇总。另外，该网站还汇总了嵌入式开发过程中经常用到的开源软件库（软件包），避免自己重复造轮子，站在巨人的肩膀上快速开发自己的应用。</p><p>和大家分享：</p><p><strong>RTOS 汇总：</strong><br><img src="https://img-blog.csdnimg.cn/20190816091814391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>开源软件包汇总：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190816092549547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式操作系统</tag>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RT-Thread Pin 设备驱动框架快速对接</title>
    <link href="/posts/a14c2161.html"/>
    <url>/posts/a14c2161.html</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要-Pin-设备驱动框架"><a href="#为什么需要-Pin-设备驱动框架" class="headerlink" title="为什么需要 Pin 设备驱动框架"></a>为什么需要 Pin 设备驱动框架</h2><ul><li>跨平台可移植应用</li><li>操作简单</li></ul><p>试想下面这个场景：</p><p>你基于 STM32 MCU 编写了一个包含很多 GPIO 操作的应用程序，GPIO 控制函数使用的是 HAL 库。<br>后面，由于某种原因，MCU 需要更换，使用的是 NXP 的芯片，不支持 HAL 库，那你怎么办？</p><p>通常，你会查找所有 <strong>GPIO 操作相关的接口</strong>，然后替换成 NXP 提供的 GPIO 驱动函数，如果 GPIO 的编排方式不一样（有的有 GPIOA 这样的分组，有的没有），那就更加的麻烦。这样，你就维护了两个版本的应用程序。</p><p>那么，有了 Pin 驱动框架能解决这个问题吗？</p><p>当然，Pin 只能解决应用层代码不需要变动的问题，但需要将 GPIO 驱动对接到 Pin 驱动框架上。<br>另外，RT-Thread Pin 设备驱动框架采用了统一 GPIO 号编排的方式，从 0 开始向上计数，每一个 GPIO 对应一个 pin 号。这样做的好处是，应用程序无需关心该 GPIO 属于哪一个组（GPIOA，还是 GPIOB），也无需关心相关 GPIO 的时钟初始化、中断等。因为，Pin 设备驱动框架都帮你抽象好了。</p><p><img src="https://img-blog.csdnimg.cn/20190710144526656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="怎么对接到-Pin-设备框架"><a href="#怎么对接到-Pin-设备框架" class="headerlink" title="怎么对接到 Pin 设备框架"></a>怎么对接到 Pin 设备框架</h2><h3 id="首先了解下文件结构"><a href="#首先了解下文件结构" class="headerlink" title="首先了解下文件结构"></a>首先了解下文件结构</h3><p>PIN 设备框架对应文件：</p><ul><li>pin.h</li><li>pin.c</li></ul><p>源文件路径： <strong>components/drivers/misc/pin.c</strong></p><p>对接到 PIN 设备框架的驱动代码需要我们自行实现（如果官方没有现成的 BSP 可以使用），为了保持驱动实现的一致性，这里有一些潜在规则：</p><ul><li>RT-Thread 通常将对接设备框架的驱动相关文件存放在对应 bsp 的 <strong>drivers</strong> 目录下</li><li>驱动程序文件命名采用 <strong>drv_</strong> 前缀加驱动名称的方式</li></ul><p>当然，并不是所有的 BSP 对接 rt-thread 设备框架的驱动程序文件都存放在 <strong>drivers</strong> 目录下，如 STM32 新 BSP  中的驱动实现在 rt-thread/bsp/stm32/libraries/HAL_Drivers 目录下。</p><p>由此，本次我们需要实现的 GPIO 驱动如下：</p><p>GPIO 驱动对应文件：</p><ul><li>drv_gpio.h</li><li>drv_gpio.c</li></ul><h3 id="PIN-驱动框架和-GPIO-驱动对接"><a href="#PIN-驱动框架和-GPIO-驱动对接" class="headerlink" title="PIN 驱动框架和 GPIO 驱动对接"></a>PIN 驱动框架和 GPIO 驱动对接</h3><p><img src="https://img-blog.csdnimg.cn/20190709223437627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>从上图可以直观地看到 Pin 设备驱动框架和 GPIO 驱动是如果对接到一起的。</p><p>如上图所示：</p><ul><li>左侧为 Pin 设备驱动框架封装的 API 接口，向上提供给应用层使用；</li><li>右侧为具体芯片平台对接 Pin 设备的驱动程序，与 Pin 设备框架提供的 API 接口一一对应，通过 rt_pin_ops 结构体关联到一起，驱动框架层接口最终会回调驱动层接口；</li><li>最后通过 rt_device_pin_register 函数接口，将底层驱动与 Pin 设备框架绑定到一起，注册到 RT-Thread 的设备框架中。</li></ul><p>在对接 RT-Thread Pin 设备框架的时候，仅需要实现上图右侧 <code>rt_pin_ops</code> 结构体中的所有 callback 回调函数即可，然后通过 <code>rt_device_pin_register</code> 注册到系统，最后使用 <code>rt_hw_pin_init</code> 调用以进行初始化。<br><code>rt_hw_pin_init</code> 在系统启动过程中被 <code>rt_hw_board_init</code> 调用。</p><p><strong>注意：</strong></p><p>需要注意的是 <code>rt_pin_attach_irq</code> 接口的使用，其函数原型如下：</p><pre><code class="C">rt_err_t rt_pin_attach_irq(rt_int32_t pin, rt_uint32_t mode,                             void (*hdr)(void *args), void  *args)</code></pre><p>该函数的功能是，为指定的 <code>pin</code> 脚绑定中断回调函数 <code>hdr</code>，并设置对应的中断模式 <code>mode</code> 。该函数是唯一的从应用层，通过 Pin 设备框架向下注册到 GPIO 驱动层的 API 接口。</p><p>用户在实现 <code>rt_pin_attach_irq</code> 对应的 <code>pin_attach_irq</code> 回调函数时，记得将 <code>hdr</code> 回调函数应用到对应 pin 脚的外部中断 Handler 中。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>RT-Thread 官方的文档中心中 Pin 设备给出了一个基本的测试例程，这里做引用，如下所示：</p><blockquote><p>以下内容引用自 RT-Thread 文档中心，地址：<a href="https://www.rt-thread.org/document/site/programming-manual/device/pin/pin/" target="_blank" rel="noopener">https://www.rt-thread.org/document/site/programming-manual/device/pin/pin/</a></p></blockquote><p>PIN 设备的具体使用方式可以参考如下示例代码，示例代码的主要步骤如下：</p><ul><li>设置蜂鸣器对应引脚为输出模式，并给一个默认的低电平状态</li><li>设置按键 0 和 按键1 对应引脚为输入模式，然后绑定中断回调函数并使能中断</li><li>按下按键 0 蜂鸣器开始响，按下按键 1 蜂鸣器停止响</li></ul><p>代码如下：</p><pre><code class="C">/* * 程序清单：这是一个 PIN 设备使用例程 * 例程导出了 pin_beep_sample 命令到控制终端 * 命令调用格式：pin_beep_sample * 程序功能：通过按键控制蜂鸣器对应引脚的电平状态控制蜂鸣器*/#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;/* 引脚编号，通过查看设备驱动文件drv_gpio.c确定 */#ifndef BEEP_PIN_NUM    #define BEEP_PIN_NUM            35  /* PB0 */#endif#ifndef KEY0_PIN_NUM    #define KEY0_PIN_NUM            55  /* PD8 */#endif#ifndef KEY1_PIN_NUM    #define KEY1_PIN_NUM            56  /* PD9 */#endifvoid beep_on(void *args){    rt_kprintf(&quot;turn on beep!\n&quot;);    rt_pin_write(BEEP_PIN_NUM, PIN_HIGH);}void beep_off(void *args){    rt_kprintf(&quot;turn off beep!\n&quot;);    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);}static void pin_beep_sample(void){    /* 蜂鸣器引脚为输出模式 */    rt_pin_mode(BEEP_PIN_NUM, PIN_MODE_OUTPUT);    /* 默认低电平 */    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);    /* 按键0引脚为输入模式 */    rt_pin_mode(KEY0_PIN_NUM, PIN_MODE_INPUT_PULLUP);    /* 绑定中断，下降沿模式，回调函数名为beep_on */    rt_pin_attach_irq(KEY0_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_on, RT_NULL);    /* 使能中断 */    rt_pin_irq_enable(KEY0_PIN_NUM, PIN_IRQ_ENABLE);    /* 按键1引脚为输入模式 */    rt_pin_mode(KEY1_PIN_NUM, PIN_MODE_INPUT_PULLUP);    /* 绑定中断，下降沿模式，回调函数名为beep_off */    rt_pin_attach_irq(KEY1_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_off, RT_NULL);    /* 使能中断 */    rt_pin_irq_enable(KEY1_PIN_NUM, PIN_IRQ_ENABLE);}/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(pin_beep_sample, pin beep sample);</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>嵌入式操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3/4 调试技巧、STM32 调试手段</title>
    <link href="/posts/e5dfd497.html"/>
    <url>/posts/e5dfd497.html</url>
    
    <content type="html"><![CDATA[<h1 id="Cortex-M3-4-一些调试技巧"><a href="#Cortex-M3-4-一些调试技巧" class="headerlink" title="Cortex-M3/4 一些调试技巧"></a>Cortex-M3/4 一些调试技巧</h1><p>今天主要总结下这段时间在没有 <strong>调试器</strong> 情况下，解决 bug 的一些辅助调试手段。</p><p>在没有 <strong>调试器</strong> 的情况下，进行代码调试的手段就只有 log 大法，为了能够尽可能详细地输出有用的调试信息，往往我们需要将 <strong>调用栈</strong> 、R0- R15 寄存器、SCB、中断状态、线程状态等信息打印出来，然后配合 <strong>反汇编</strong> 进行调试跟踪代码。这会用到一些特殊的函数（内链汇编函数），下面将介绍我用到的汇编函数，这些都基于 GUN GCC 工具链。</p><h2 id="获取中断号"><a href="#获取中断号" class="headerlink" title="获取中断号"></a>获取中断号</h2><p>获取中断号是通过系统控制块 SCB 寄存器来获取，参考如下：</p><pre><code>#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!&lt; SCB ICSR: VECTACTIVE Position */#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL &lt;&lt; SCB_ICSR_VECTACTIVE_Pos)           /*!&lt; SCB ICSR: VECTACTIVE Mask */uint32_t get_current_irq(){    return (((SCB-&gt;ICSR &amp; SCB_ICSR_VECTACTIVE_Msk) &gt;&gt; SCB_ICSR_VECTACTIVE_Pos) - 16);}</code></pre><h2 id="查看设置中断优先级"><a href="#查看设置中断优先级" class="headerlink" title="查看设置中断优先级"></a>查看设置中断优先级</h2><ul><li>NVIC_SetPriority(IRQn_Type IRQn) 设置指定中断优先级</li><li>NVIC_GetPriority(IRQn_Type IRQn) 查看指定中断优先级</li></ul><h2 id="判断当前工作状态（中断状态-or-线程状态）"><a href="#判断当前工作状态（中断状态-or-线程状态）" class="headerlink" title="判断当前工作状态（中断状态 or 线程状态）"></a>判断当前工作状态（中断状态 or 线程状态）</h2><p>获取工作状态是在中断状态还是线程状态，利用了 <strong>主栈指针</strong> MSP 和 <strong>线程栈</strong> 指针 PSP，如果在中断状态下，MSP == PSP；相反，如果在线程状态下，MSP != PSP。</p><pre><code>__attribute__( ( always_inline ) ) static inline uint32_t _get_msp(void) {    register uint32_t result;    __asm volatile (&quot;MRS %0, msp\n&quot; : &quot;=r&quot; (result) );    return(result);}__attribute__( ( always_inline ) ) static inline uint32_t _get_psp(void) {    register uint32_t result;    __asm volatile (&quot;MRS %0, psp\n&quot; : &quot;=r&quot; (result) );    return(result);}if (_get_msp() == _get_psp()) /* in isr */{}else /* in task */{}</code></pre><p>当然，也可以直接通过检查 CONTROL 寄存器第 1 位来确定当前在线程模式还是处理模式。</p><h2 id="查看当前特权等级"><a href="#查看当前特权等级" class="headerlink" title="查看当前特权等级"></a>查看当前特权等级</h2><p>可以通过检查 CONTROL 和 IPSR 寄存器来确定当前是否处于特权等级。</p><ul><li>CONTROL 寄存器第 0 位为标识线程模式中的特权等级</li><li>IPSR 寄存器存储异常 / 中断编号，非 0 则为处理模式，处理模式属于特权等级</li></ul><p>这里使用 CMSIS 接口来进行判断：</p><pre><code>int is_privileged_mode (void){    if (_get_IPSR() != 0 )    {        return 1; /* 特权等级 */    }    else if ((_get_CONTROL() &amp; 0x01) == 0)    {        return 1; /* 特权等级 */    }    else    {        return 0; /* 非特权等级 */    }}</code></pre><h2 id="查看调用者函数（通过-LR-寄存器）"><a href="#查看调用者函数（通过-LR-寄存器）" class="headerlink" title="查看调用者函数（通过 LR 寄存器）"></a>查看调用者函数（通过 LR 寄存器）</h2><p>LR 寄存器保存着被调用函数的返回地址，拿到这个返回地址后，在反汇编文件中，查找该地址，即可得到调用者函数。使用该函数的时候，必须是函数入口处的第一个函数，如果在此函数（__get_LR）之前调用了其他函数，那么得到的 LR 指针就不再是原来调用者函数返回地址了。<br><strong>注意：</strong><br>在 Cortex-M3/4 平台下，LR 寄存器保存的返回地址通常是<strong>基数</strong>，这是因为 Cortex-M 平台有些跳转 / 调用操作需要将地址的第 0 位置 1 以表示操作模式为 Thumb 状态，因此在使用该地址的时候，请自动将基数地址减一，然后到反汇编文件中查找。</p><pre><code>__attribute__( ( always_inline ) ) static inline uint32_t __get_LR(void){    register uint32_t result;    __ASM volatile (&quot;mov %0, lr\n&quot; : &quot;=r&quot; (result) );    return(result);}</code></pre><h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><pre><code>arm-none-eabi-objdump -d xxx.elf &gt; xxx.asm</code></pre><h2 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h2><pre><code>arm-none-eabi-objdump -t xxx.elf &gt; xxx.sym</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以上代码基于 Cortex-M4 SOC，GNU GCC gcc-arm-none-eabi-4_8-2014q3 工具链版本编译测试。</p><h3 id="关于-LR-寄存器"><a href="#关于-LR-寄存器" class="headerlink" title="关于 LR 寄存器"></a>关于 LR 寄存器</h3><p>链接寄存器（LR）用于函数或子程序调用时 <strong>返回地址</strong> 的保存，当执行了函数或子程序调用后，LR 的数值会自动更新。因此，在执行函数或子程序调用前，需要将 LR 寄存器压入栈中保存，否则 LR 当前值丢失，无法返回最初的函数调用返回地址。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>Cortex M3</tag>
      
      <tag>Cortex M4</tag>
      
      <tag>STM32</tag>
      
      <tag>STM32 调试方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 RT-Thread netdev 结构体与 lwip 结构体不匹配 bug 的调试过程</title>
    <link href="/posts/3e8516c9.html"/>
    <url>/posts/3e8516c9.html</url>
    
    <content type="html"><![CDATA[<p>本文主要记录在使用 RT-Thread Netdev 组件的时候遇到的一个结构体不匹配的 bug。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本次 bug 只要涉及 4 个文件：</p><ul><li>netdev.h：定义了 <code>struct netdev</code> 数据结构</li><li>netdev.c：netdev 源码实现，这里主要涉及 <strong>netdev_low_level_set_link_status</strong> 接口</li><li>netif.c：lwip 网卡相关接口，这里主要涉及 <strong>netif_set_link_up</strong> 接口</li><li>ethernetif.c：lwip 网卡初始化部分代码。这里注册 netdev 设备，涉及 <strong>netdev_add</strong> 接口</li></ul><p><strong>netdev 数据结构如下：</strong></p><pre><code>struct netdev{    rt_slist_t list;     char name[RT_NAME_MAX];                            /* network interface device name */    ip_addr_t ip_addr;                                 /* IP address */    ip_addr_t netmask;                                 /* subnet mask */    ip_addr_t gw;                                      /* gateway */    ip_addr_t dns_servers[NETDEV_DNS_SERVERS_NUM];     /* DNS server */    uint8_t hwaddr_len;                                /* hardware address length */    uint8_t hwaddr[NETDEV_HWADDR_MAX_LEN];             /* hardware address */    uint16_t flags;                                    /* network interface device status flag */    uint16_t mtu;                                      /* maximum transfer unit (in bytes) */    const struct netdev_ops *ops;                      /* network interface device operations */    netdev_callback_fn status_callback;                /* network interface device flags change callback */    netdev_callback_fn addr_callback;                  /* network interface device address information change callback */#ifdef RT_USING_SAL    void *sal_user_data;                               /* user-specific data for SAL */#endif /* RT_USING_SAL */    void *user_data;                                   /* user-specific data */};</code></pre><p>另外，运行程序的设备没有调试接口，只有 UART！<strong>只能通过串口打日志！</strong></p><h2 id="bug-现象"><a href="#bug-现象" class="headerlink" title="bug 现象"></a>bug 现象</h2><p>ethernetif.c 中中调用 <code>static int netdev_add(struct netif *lwip_netif)</code> 注册一个 netdev 设备（malloc 方式创建一个设备），并基于 lwip netif 初始化 netdev 数据结构。</p><p>此时，netdev 数据结构中的各成员初值配置无误，一切正常。</p><p>当 lwip 网卡初始化完成，设置 linkup 状态，调用函数 <code>void netif_set_link_up(struct netif *netif)</code>。<strong>netif_set_link_up</strong> 函数再调用 <code>void netdev_low_level_set_link_status(struct netdev *netdev, rt_bool_t is_up)</code> 接口，设置 netdev 设备 linkup 状态。</p><p>在 <strong>netdev_low_level_set_link_status</strong> 函数中操作 netdev 数据结构成员，然后就<strong>出现了问题</strong>！</p><p><strong>问题是 netdev 数据结构成员的值与初始化的值不一样！</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般这种问题，我们会理所当然地认为 <strong>netdev</strong> 数据结构所在的内存块被 xxx 写穿了。</p><p>然后就有了下面的一通操作：</p><ol><li><p>对该数据结构所有可能被写穿的地方进行了排查，无解！</p></li><li><p>加 log，检查 netdev 数据结构从哪里开始出现问题。这个时候发现有的 log 打印输出是对的（ethernetif.c 中是对的），有的地方是错的（netdev.c 中是错的）！</p></li><li><p>猜想：代码优化所致？</p></li><li><p>编译器优化？加 <code>volatile</code>，不行！</p></li><li><p>设置局部优化，依旧不行！</p><pre><code> #pragma GCC push_options #pragma GCC optimize (&quot;O0&quot;) /* TODO Your code */ #pragma GCC pop_options</code></pre></li><li><p>dump <strong>netdev</strong> 数据结构所在内存（乍一看，内存中的数据好像是正确的）</p></li><li><p>回顾：内存数据正确，编译器优化问题也排除了，内存写穿的可能性很小！<strong>奇了怪了</strong></p></li><li><p>经同事提醒，可能引入了另外一个 netdev 数据结构！思索了下，不太可能存在数据成员一致的另外一个 netdev 结构体。</p></li><li><p>既然没办法，就验证下正常 log 输出的地方和异常 log 输出的地方的数据结构的大小是否一致，数据成员的地址是否一致即可</p></li><li><p>验证结果惊喜！两边数据结构大小不一致！<strong>Why？</strong> </p></li><li><p>再次检查 netdev 数据结构，并 dump netdev 数据结构内存，发现了猫腻（结构体最后一个成员的位置不对，没有在内存的最后一块地址）。那么说明结构体确实不匹配</p></li><li><p>检查发现，netdev 结构中使用的 <strong>ip_addr_t</strong> 存在问题</p></li></ol><p>在使用 ipv4 的时候，是 ip4_addr_t；在使用 ipv6 的时候，是 ip6_addr_t；<br>检查我的配置，发现 lwipopts.h 同时开启了 IPV4 和 IPV6，而 RT-Thread 的 Netdev 只支持 IPV4。</p><p>So，那么问题明朗了！总结见下。</p><ol start="13"><li>总结</li></ol><p>在 ethernetif.c 中创建的 netdev 设备使用的 ip_addr_t 为：</p><pre><code>typedef struct _ip_addr {  union {    ip6_addr_t ip6;    ip4_addr_t ip4;  } u_addr;  u8_t type;} ip_addr_t;</code></pre><p>在 netdev.c 中，使用的 ip_addr_t 为：</p><pre><code>typedef struct ip4_addr{    uint32_t addr;} ip4_addr_t;typedef ip4_addr_t ip_addr_t;</code></pre><p>因此，ethernetif.c 和 netdev.c 操作的数据结构不一致，所以在 ethernetif.c 中打印输出的数据成员是正确的（因为在 ethernetif.c 中创建的 netdev 设备对象）。<br>解决方案，升级 RT-Thread Netdev 组件，以支持 IPV6 和 IPV4 共用的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题确实很坑！以我现在的经验，在没有调试器的情况下，定位这类问题相对困难。因此，通过本文记录下分析这类问题可能的手段。（中间我还反汇编看了下汇编代码，然并卵，没有用）<br>本文的 bug 分析过程直接耦合我的应用场景，如果你遇到上述的 BUG 现象，那么能记得检查结构体是否存在不一致的情况。很有可能您就避免了整个上述的分析过程（都是泪 :cry: ）。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread netdev</tag>
      
      <tag>lwip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NB-IOT MT2625 TCP 连接测试</title>
    <link href="/posts/a3fe834f.html"/>
    <url>/posts/a3fe834f.html</url>
    
    <content type="html"><![CDATA[<h1 id="MT2625-NB-IOT-TCP-测试（基于-MTK-MT2625-NB-IOT-AT-指令）"><a href="#MT2625-NB-IOT-TCP-测试（基于-MTK-MT2625-NB-IOT-AT-指令）" class="headerlink" title="MT2625 NB-IOT TCP 测试（基于 MTK MT2625 NB-IOT AT 指令）"></a>MT2625 NB-IOT TCP 测试（基于 MTK MT2625 NB-IOT AT 指令）</h1><p>本文涉及的 AT 命令是基于 MTK 官方提供的 MT2625 NB-IOT AT 指令，<strong>非</strong> 移远（如 BC26）和中移物联网（如 M5311）提供的 AT 指令。</p><p>另外，本文仅使用 AT 指令测试 MTK MT2625 AT 固件的网络连接，并不对 AT 指令做详细说明，如有需求请阅读 MTK 官方提供的 <strong>MT2625_NB-IOT_AT_Command_Specification.pdf</strong> 和 <strong>LinkIt_MT2625_Proprietary_Non-Modem_AT_Command_Manua.pdf</strong>。</p><blockquote><p>有时间的话，会单独写一篇常用 AT 命令文章，用于介绍常用 AT 命令，及如何使用。</p></blockquote><h2 id="创建-TCP-连接"><a href="#创建-TCP-连接" class="headerlink" title="创建 TCP 连接"></a>创建 TCP 连接</h2><ol><li>查询 apn</li></ol><p>输入：</p><pre><code>AT+CGDCONT?</code></pre><p>响应：</p><pre><code>+CGDCONT: 1,&quot;IP&quot;,&quot;cmnbiot6&quot;,&quot;&quot;,0,0,0,,,,,,0,,0OK</code></pre><ol start="2"><li>激活 apn</li></ol><p>输入：</p><pre><code>AT+EGACT=1,1,&quot;cmnbiot6&quot;,&quot;&quot;,&quot;&quot;</code></pre><p>其中 <strong>“cmnbiot6”</strong> 是从步骤 1 查询 apn 中获取到的。</p><p>响应：</p><pre><code>+EGACT:1,1,1,1OK</code></pre><ol start="3"><li>创建 socket</li></ol><p>输入：</p><pre><code>AT+ESOC=1,1,1</code></pre><p>响应：</p><p>返回 socket id。</p><pre><code>+ESOC=0OK</code></pre><ol start="4"><li>建立连接</li></ol><p>输入：</p><p>第一个参数为 socket id；第二个参数为 TCP 服务器端口号；第三个参数为 TCP 服务器 IP 地址。</p><p><strong>注意：</strong> 这里需要填写你自己的<strong>公网 TCP 服务器地址</strong>和对应的端口号。</p><pre><code>AT+ESOCON=0,2039,&quot;114.116.xxx.xxx&quot;</code></pre><p>响应：</p><pre><code>OK+ESONMI=0,37,0d0a3131372e3133322e3139362e31343a353132343820434f4e4e4543544544204f4b0d0a</code></pre><ol start="5"><li>发送数据</li></ol><p>输入：</p><p>第一个参数为 socket id；第二个参数为发送数据的长度（hex 数据长度）；第三个参数为 hex 编码的字符串数据（3132 对应的 ASCII 字符串为 12）。</p><pre><code>AT+ESOSEND=0,2,3132</code></pre><p>响应：</p><pre><code>OK</code></pre><ol start="6"><li>关闭 socket</li></ol><p>输入：</p><p>第一个参数为 socket id。</p><pre><code>AT+ESOCL=0</code></pre><p>响应：</p><pre><code>OK</code></pre>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NB-IOT</tag>
      
      <tag>MT2625</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP Client 客户端示例程序</title>
    <link href="/posts/a812870.html"/>
    <url>/posts/a812870.html</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-client-示例程序"><a href="#TCP-client-示例程序" class="headerlink" title="TCP client 示例程序"></a>TCP client 示例程序</h1><blockquote><p>最近总有人问我要 TCP 的客户端代码，就拿手上用来测试的代码分享出来吧。</p></blockquote><p><strong>关键词：</strong></p><pre><code>TCP 客户端代码TCP client 代码LWIP TCP 客户端程序LWIP TCP client 代码</code></pre><p>每一次调试网络相关的代码都需要一段最简单的 TCP 测试程序，后来就把这个程序记录到了代码片段，今天在自己的博客里再次记录下，希望更方便查找。</p><h2 id="简单的-TCP-客户端程序源码"><a href="#简单的-TCP-客户端程序源码" class="headerlink" title="简单的 TCP 客户端程序源码"></a>简单的 TCP 客户端程序源码</h2><p>本代码在 RT-Thread OS 下测试使用，并验证通过。</p><ul><li><p>如果定义了 <strong>RT_USING_SAL</strong> 宏，那么使用 RT-Thread SAL 组件提供的 socket 封装，需要引用 SAL 相关头文件</p><pre><code>  #include &lt;sys/socket.h&gt;  #include &lt;netdb.h&gt;</code></pre></li><li><p>如果没有定义 <strong>RT_USING_SAL</strong> 宏，直接使用 lwip socket，包含 lwip 相关头文件</p><pre><code>  #include &quot;lwip/sockets.h&quot;  #include &quot;lwip/netdb.h&quot;  #include &quot;lwip/sys.h&quot;</code></pre></li></ul><hr><p>源码如下所示：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;rtthread.h&gt;#ifdef RT_USING_SAL#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;#else#include &quot;lwip/sockets.h&quot;#include &quot;lwip/netdb.h&quot;#include &quot;lwip/sys.h&quot;#endif#define SAL_TCP_TEST_HOST    &quot;your host or ip addr&quot;  /* 输入你的 TCP server 域名或者 ip 地址 */#define SAL_TCP_TEST_PORT    (80u)                   /* 输入你的 TCP Server 断口号 */#define SAL_TEST_BUFSZ       (1024u)static const char *send_tcp_req_data = &quot;Hi, I am from tcp client.&quot;;static void _sal_tcp_test(void){    int ret, i;    char *recv_data;    struct hostent *host;    int sock = -1, bytes_received;    struct sockaddr_in server_addr;    /* 通过函数入口参数url获得host地址（如果是域名，会做域名解析） */    host = gethostbyname(SAL_TCP_TEST_HOST);    if (!host)    {        rt_kprintf(&quot;gethostbyname failed!\r\n&quot;);        return;    }    else    {        rt_kprintf(&quot;gethostbyname success!\r\n&quot;);    }    recv_data = rt_calloc(1, SAL_TEST_BUFSZ);    if (recv_data == RT_NULL)    {        rt_kprintf(&quot;No memory\n&quot;);        return;    }    /* 创建一个socket，类型是SOCKET_STREAM，TCP 协议, TLS 类型 */    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)    {        rt_kprintf(&quot;Socket error\n&quot;);        goto __exit;    }    else    {        rt_kprintf(&quot;Socket pass\n&quot;);    }    /* 初始化预连接的服务端地址 */    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SAL_TCP_TEST_PORT);    server_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);    rt_memset(&amp;(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));    rt_kprintf(&quot;will connect...\n&quot;);    if (connect(sock, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)) &lt; 0)    {        rt_kprintf(&quot;Connect fail!\n&quot;);        goto __exit;    }    else    {        rt_kprintf(&quot;Connect pass!\n&quot;);    }    /* 发送数据到 socket 连接 */    ret = send(sock, send_tcp_req_data, strlen(send_tcp_req_data), 0);    if (ret &lt;= 0)    {        rt_kprintf(&quot;send error,close the socket.\n&quot;);        goto __exit;    }    else    {        rt_kprintf(&quot;send pass!\n&quot;);    }    /* 接收并打印响应的数据，使用加密数据传输 */    bytes_received = recv(sock, recv_data, SAL_TEST_BUFSZ  - 1, 0);    if (bytes_received &lt;= 0)    {        rt_kprintf(&quot;received error,close the socket.\n&quot;);        goto __exit;    }    rt_kprintf(&quot;recv data:\n&quot;);    for (i = 0; i &lt; bytes_received; i++)    {        rt_kprintf(&quot;%c&quot;, recv_data[i]);    }__exit:    if (recv_data)        rt_free(recv_data);    if (sock &gt;= 0)        closesocket(sock);}static void sal_tcp_test(void){    rt_thread_t tid;    tid = rt_thread_create(&quot;sal_tcp&quot;, _sal_tcp_test, RT_NULL, 4096, 23, 5);    if (tid)        rt_thread_startup(tid);    else    {        rt_kprintf(&quot;sal_tcp thread create failed!\r\n&quot;);    }}#ifdef FINSH_USING_MSH#include &lt;finsh.h&gt;MSH_CMD_EXPORT(sal_tcp_test, SAL TCP function test);#endif /* FINSH_USING_MSH */</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在 RT-Thread MSH 中可以直接使用 Finsh 命令运行：</p><pre><code>msh /&gt; sal_tcp_test</code></pre><p>如果不使用 RT-Thread，只需要将 RT-Thread 特性移除即可。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>TCP Client</tag>
      
      <tag>TCP 客户端</tag>
      
      <tag>LWIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【工具分享】图片的方式分享代码 #Carbon# 代码截图工具</title>
    <link href="/posts/caaf7beb.html"/>
    <url>/posts/caaf7beb.html</url>
    
    <content type="html"><![CDATA[<h1 id="图片的方式分享代码之-Carbon"><a href="#图片的方式分享代码之-Carbon" class="headerlink" title="图片的方式分享代码之 Carbon"></a>图片的方式分享代码之 Carbon</h1><p>今天逛知乎，发现了一个非常实用的工具（Carbon）—— 图片的方式分享代码，这里做个记录，同时分享出来，好东西大家一起用。</p><p>无论你是发推还是发朋友圈，或者是贴到 PPT里，通常的方式，就是使用 QQ 或者微信截图的方式获取，快捷，但不那么美观，<a href="https://carbon.now.sh" target="_blank" rel="noopener"><strong>Carbon</strong></a> 的出现，完美解决了这个问题，地址 <a href="https://carbon.now.sh" target="_blank" rel="noopener">https://carbon.now.sh</a> 。知乎参考地址<a href="https://zhuanlan.zhihu.com/p/35811981?utm_source=wechat_session&utm_medium=social&utm_oi=730490921728086016" target="_blank" rel="noopener">点我</a>。</p><p>拿手头上用的 C 语言代码实验：</p><p><img src="https://img-blog.csdnimg.cn/20190503145155930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNDk2Nzk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Carbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同编译器下 errno 与 RT-Thread 的对接</title>
    <link href="/posts/bda4e1f6.html"/>
    <url>/posts/bda4e1f6.html</url>
    
    <content type="html"><![CDATA[<h2 id="支持的编译器"><a href="#支持的编译器" class="headerlink" title="支持的编译器"></a>支持的编译器</h2><p>RT-Thread 支持的编译器有 newlib/minilibc/dlib/armlibc 的支持。</p><ul><li>在开启了 RT_USING_LIBC 后，GCC 编译使用 newlib</li><li>未开启 RT_USING_LIBC 时，GCC 编译使用 minilibc</li><li>dlib 是 RT-Thread 针对 IAR 编译器的移植适配（使用标准库接口时注意开启 RT_USING_LIBC）</li><li>armlibc 是 RT-Thread 针对 MDK 编译器的移植适配</li></ul><h2 id="errno-的重定向"><a href="#errno-的重定向" class="headerlink" title="errno 的重定向"></a>errno 的重定向</h2><p>通常 errno 的声明在 <code>errno.h</code> 文件中。<code>errno.h</code> 在 RT-Thread 中的引入顺序如下所示：</p><pre><code>rtthread.h -&gt; rtdef.h -&gt; rtlibc.h -&gt; libc_errno.h</code></pre><p>因此，如果需要对 errno 进行重定向，那么需要在引入 <code>errno.h</code> 之后，重新在 rtthread.h 中实现 errno 设置函数。</p><p>在 rtthread.h 中对 errno 的重定向如下所示：</p><pre><code>#if !defined(RT_USING_NEWLIB) &amp;&amp; !defined(_WIN32)#ifndef errno#define errno    *_rt_errno()#endif#endif</code></pre><p>如上代码所示，当使用非 NEWLIB 编译器，非 WIN32 的时候，并且没有定义过 errno，才会对 errno 进行重定向。</p><p>在 libc_errno.h 中，errno.h 的引入如下所示：</p><pre><code>#if defined(RT_USING_NEWLIB) || defined(_WIN32)/* use errno.h file in toolchains */#include &lt;errno.h&gt;#endif</code></pre><p>总结：</p><ul><li><p>当使用 NWELIB 编译器时</p><p>  在 rtthread.h 中没有重定向 errno，在 libc_errno.h 中引入了 errno.h，在 rt-thread/components/libc/compilers/newlib/syscalls.c 中对 errno 函数进行了再次实现，如下所示。因此，使用 NEWLIB 可以正确重定向 errno。</p><pre><code>  #ifndef _REENT_ONLY  int *  __errno ()  {  return _rt_errno();  }  #endif</code></pre></li><li><p>当使用 MINILIB 编译器时</p><p>  未开启 RT_USING_LIBC，使用 GCC 编译，这个时候使用 MINILIB 编译器编译。这时，libc_errno.h 中没有引入 errno.h，也就未定义 errno，那么 rtthread.h 中就将 errno 重定向到 _rt_errno() 函数。</p></li><li><p>当使用 IAR 编译器时</p><p>  同 MINILIB。</p></li><li><p>当使用 ARMCC 编译器时</p><p>  同 MINILIB。</p></li></ul><p><strong>注意：</strong></p><p>以上所有的原则是，没有在 rtthread.h 之前的其他任何地方引入 errno.h。如果在 rtthread.h 之前引入了 errno.h，那么就会定义 errno，那么在 rtthread.h 中就不会将 errno 重定向到 _rt_errno() 函数。</p><blockquote><p>在 lwip 的其他地方有引入 errno.h，需要注意。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>errno</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灵活的按键处理程序 FlexibleButton</title>
    <link href="/posts/91f5c94b.html"/>
    <url>/posts/91f5c94b.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>灵活的按键处理程序 FlexibleButton，C程序编写，无缝兼容任意的处理器，支持任意 OS 和裸机编程。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正好工作中用到按键处理，需要处理单击、长按等按键事件，然后就造了这么一个轮子，为了以后更方便地加入其它的项目中使用，遂将其开源到 GitHub 中。</p><p>后面发现 RT-Thread 软件包里也有一个开源的按键库 <a href="https://github.com/liu2guang/MultiButton" target="_blank" rel="noopener">MultiButton</a>，看到这个按键库的时候，心想，完了，又重复造轮子了，好伤心 :joy:。想想，既然按键处理方式不同，而且时间已经花出去了，那就把轮子圆一圆，放到 GitHub 中，给有缘人用吧，然后就有了这个不太圆的轮子 <a href="https://github.com/murphyzhao/FlexibleButton" target="_blank" rel="noopener">FlexibleButton</a>。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>FlexibleButton 是一个基于 C 语言的小巧灵活的按键处理库。该按键库解耦了具体的按键硬件结构，理论上支持轻触按键与自锁按键，并可以无限扩展按键数量。另外，FlexibleButton 使用扫描的方式一次性读取所有所有的按键状态，然后通过事件回调机制上报按键事件。</p><p>该按键库使用 C 语言编写，驱动与应用程序解耦，便于灵活应用，比如用户可以方便地在应用层增加按键中断、处理按键功耗、定义按键事件处理方式，而无需修改 FlexibleButton 库中的代码。</p><p>另外，使用 C 语言标准库 API 编写，也使得该按键库可以无缝兼容任意的处理器平台，并且支持任意 OS 和 non-OS（裸机程序）。</p><p>另外，该按键库核心的按键扫描代码仅有三行，没错，就是经典的<strong>三行按键扫描算法</strong>，出自哪位大神之手就无从得知了，也欢迎知道此高人的读者文后留言哈。算法介绍可以去搜索引擎里查找，这里就不作介绍了。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><pre><code class="SHELL">git clone https://github.com/murphyzhao/FlexibleButton.git</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>FlexibleButton 库中提供了一个 DEMO <code>flexible_button_demo.c</code>，这里基于 RT-Thread OS 进行测试，当然你可以选择使用其他的 OS，或者使用裸机测试，只需要移除 OS 相关的特性即可。</p><p>将 FlexibleButton 库放到 RT-Thread BSP 下即可使用 scons 进行编译构建。</p><h2 id="DEMO-程序说明"><a href="#DEMO-程序说明" class="headerlink" title="DEMO 程序说明"></a>DEMO 程序说明</h2><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><pre><code class="C">int flex_button_main(void){    rt_thread_t tid = RT_NULL;    user_button_init();    /* Create background ticks thread */    tid = rt_thread_create(&quot;flex_btn&quot;, button_scan, RT_NULL, 1024, 10, 10);    if(tid != RT_NULL)    {        rt_thread_startup(tid);    }    return 0;}INIT_APP_EXPORT(flex_button_main);</code></pre><p>如上所示，首先使用 <code>user_button_init();</code> 初始化用户按键硬件，并挂载到 FlexibleButton库。然后，使用了 RT-Thread 的 <code>INIT_APP_EXPORT</code> 接口导出为上电自动初始化，创建了一个 “flex_btn” 名字的按键扫描线程，线程里扫描检查按键事件。</p><h3 id="用户初始化代码"><a href="#用户初始化代码" class="headerlink" title="用户初始化代码"></a>用户初始化代码</h3><p> <code>user_button_init();</code> 初始化代码如下所示：</p><pre><code class="C">static void user_button_init(void){    int i;    rt_memset(&amp;user_button[0], 0x0, sizeof(user_button));    user_button[USER_BUTTON_0].usr_button_read = button_key0_read;    user_button[USER_BUTTON_0].cb = (flex_button_response_callback)btn_0_cb;    user_button[USER_BUTTON_1].usr_button_read = button_key1_read;    user_button[USER_BUTTON_1].cb = (flex_button_response_callback)btn_1_cb;    user_button[USER_BUTTON_2].usr_button_read = button_key2_read;    user_button[USER_BUTTON_3].usr_button_read = button_keywkup_read;    rt_pin_mode(PIN_KEY0, PIN_MODE_INPUT); /* set KEY pin mode to input */    rt_pin_mode(PIN_KEY1, PIN_MODE_INPUT); /* set KEY pin mode to input */    rt_pin_mode(PIN_KEY2, PIN_MODE_INPUT); /* set KEY pin mode to input */    rt_pin_mode(PIN_WK_UP, PIN_MODE_INPUT); /* set KEY pin mode to input */    for (i = 0; i &lt; USER_BUTTON_MAX; i ++)    {        user_button[i].status = 0;        user_button[i].pressed_logic_level = 0;        user_button[i].click_start_tick = 20;        user_button[i].short_press_start_tick = 100;        user_button[i].long_press_start_tick = 200;        user_button[i].long_hold_start_tick = 300;        if (i == USER_BUTTON_3)        {            user_button[USER_BUTTON_3].pressed_logic_level = 1;        }        flex_button_register(&amp;user_button[i]);    }}</code></pre><p> <code>user_button_init();</code> 主要用于初始化按键硬件，设置按键长按和短按的 tick 数（RT-Thread上面默认一个 tick 为 1ms），然后注册按键到 FlexibleButton 库。</p><h3 id="事件处理代码"><a href="#事件处理代码" class="headerlink" title="事件处理代码"></a>事件处理代码</h3><pre><code class="C">static void btn_0_cb(flex_button_t *btn){    rt_kprintf(&quot;btn_0_cb\n&quot;);    switch (btn-&gt;event)    {        case FLEX_BTN_PRESS_DOWN:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_DOWN]\n&quot;);            break;        case FLEX_BTN_PRESS_CLICK:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_CLICK]\n&quot;);            break;        case FLEX_BTN_PRESS_DOUBLE_CLICK:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_DOUBLE_CLICK]\n&quot;);            break;        case FLEX_BTN_PRESS_SHORT_START:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_SHORT_START]\n&quot;);            break;        case FLEX_BTN_PRESS_SHORT_UP:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_SHORT_UP]\n&quot;);            break;        case FLEX_BTN_PRESS_LONG_START:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_LONG_START]\n&quot;);            break;        case FLEX_BTN_PRESS_LONG_UP:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_LONG_UP]\n&quot;);            break;        case FLEX_BTN_PRESS_LONG_HOLD:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_LONG_HOLD]\n&quot;);            break;        case FLEX_BTN_PRESS_LONG_HOLD_UP:            rt_kprintf(&quot;btn_0_cb [FLEX_BTN_PRESS_LONG_HOLD_UP]\n&quot;);            break;    }}</code></pre><h2 id="FlexibleButton-代码说明"><a href="#FlexibleButton-代码说明" class="headerlink" title="FlexibleButton 代码说明"></a>FlexibleButton 代码说明</h2><h3 id="按键事件定义"><a href="#按键事件定义" class="headerlink" title="按键事件定义"></a>按键事件定义</h3><p>按键事件的定义并没有使用 Windows 驱动上的定义，主要是方便嵌入式设备中的应用场景（也可能是我理解的偏差），按键事件定义如下：</p><pre><code class="C">typedef enum{    FLEX_BTN_PRESS_DOWN = 0,        // 按下事件    FLEX_BTN_PRESS_CLICK,           // 单击事件    FLEX_BTN_PRESS_DOUBLE_CLICK,    // 双击事件    FLEX_BTN_PRESS_SHORT_START,     // 短按开始事件    FLEX_BTN_PRESS_SHORT_UP,        // 短按抬起事件    FLEX_BTN_PRESS_LONG_START,      // 长按开始事件    FLEX_BTN_PRESS_LONG_UP,         // 长按抬起事件    FLEX_BTN_PRESS_LONG_HOLD,       // 长按保持事件    FLEX_BTN_PRESS_LONG_HOLD_UP,    // 长按保持的抬起事件    FLEX_BTN_PRESS_MAX,    FLEX_BTN_PRESS_NONE,} flex_button_event_t;</code></pre><h3 id="按键注册接口"><a href="#按键注册接口" class="headerlink" title="按键注册接口"></a>按键注册接口</h3><p>使用该接口注册一个用户按键，入参为一个 flex_button_t 结构体实例的地址。</p><pre><code class="C">int8_t flex_button_register(flex_button_t *button);</code></pre><h3 id="按键事件读取接口"><a href="#按键事件读取接口" class="headerlink" title="按键事件读取接口"></a>按键事件读取接口</h3><p>使用该接口获取指定按键的事件。</p><pre><code class="C">flex_button_event_t flex_button_event_read(flex_button_t* button);</code></pre><h3 id="按键扫描接口"><a href="#按键扫描接口" class="headerlink" title="按键扫描接口"></a>按键扫描接口</h3><p>按键扫描的核心函数，需要放到应用程序中定时扫描间隔 5-20ms 即可。</p><pre><code class="C">void flex_button_scan(void);</code></pre><h2 id="问题和建议"><a href="#问题和建议" class="headerlink" title="问题和建议"></a>问题和建议</h2><p>如果您在应用的时候遇到了问题，或者有好的想法和建议，欢迎到这个 <a href="https://github.com/murphyzhao/FlexibleButton/issues/1" target="_blank" rel="noopener">issue</a> 上讨论，谢谢。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RT-Thread</tag>
      
      <tag>FlexibleButton</tag>
      
      <tag>按键处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
